<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Nick Demming -> Testing and Benchmarking Software in Haskell @</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />

    <!-- <script src="https://kit.fontawesome.com/a076d05399.js"></script> -->

    <script type="text/x-mathjax-config"> 
      MathJax.Hub.Config({
      <!-- config: ["MMLorHTML.js"], -->
      <!-- jax: ["input/TeX", "output/HTML-CSS", "output/PreviewHTML", ], -->

      <!-- extensions: [ -->
      <!--   "tex2jax.js", -->
      <!--   "MathMenu.js","MathZoom.js", "fast-preview.js", --> 
      <!--   "a11y/accessibility-menu.js" -->
      <!-- ], -->

      <!-- TeX: { -->
      <!--   extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"] -->
      <!-- } -->

      <!-- "HTML-CSS": { -->
      <!--   fonts: ["STIX", "TeX"] -->
      <!-- , scale: 95 -->
      <!-- , avaliableFonts: ["STIX", "TeX"] -->
      <!-- , preferredFont: "TeX" -->
      <!-- , webFont: "TeX" -->
      <!-- } -->
      });
    </script>

    <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML">
        <!-- src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.0.1/MathJax.js"> -->
        <!-- src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"> -->
        <!-- src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML"> -->
        <!-- src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"> -->
    </script>
  </head>

  <body>
    <div id="header">

      <div id="logo">
        <a href="../">Nick Demming</a>
      </div>

      <div id="navigation">
        <a href="../">Home</a>
        <a href="../about.html">About</a>
        <a href="../contact.html">Contact</a>
        <a href="../archive.html">Archive</a>

        <a href="../rss.xml">RSS</a>
        <a href="../atom.xml">Atom</a>
      </div>
    </div>

    <div id="content">
      <h1>Testing and Benchmarking Software in Haskell</h1>

      <div class="info">
    Posted on March 26, 2020
    
</div>

<h1 id="the-setting">The Setting</h1>
<p>Haskell is renowned for its <a href="https://hackage.haskell.org/packages/#cat:Testing">testing facilities</a>.</p>
<p>There is an ambiguity in the usage of the term “framework,” related to different contexts and scopes of the notion. For our purposes, we will call libraries such as HUnit and QuickCheck, but also HSpec, that provide an idiosyncratic formalism for the expression of tests, a “<strong>testing library</strong>,” whereas test-framewok, HTF, and tasty, but also HSpec, that introduce a unifying interface to more than one testing library, a “<strong>testing framework</strong>.” Apparently, HSpec belongs to both categories, for it comprises other testing libraries and at the same time provides own formalism for expressing tests.</p>
<p>Some major popular testing libraries (also call themselves “frameworks”, in which case the next group can be termed “meta-frameworks”):</p>
<ul>
<li>doctest</li>
<li>HSpec (cf. RSpec, Mocha, etc.; a peculiar test formalism in its own right, but also a framework unifying HUnit, QuickCheck, SmallCheck)</li>
<li>HUnit</li>
<li>QuickCheck</li>
<li>SmallCheck</li>
<li>Hedgehog:</li>
</ul>
<p>Some major testing frameworks that provide a unifying layer or interface atop of the testing libraries:</p>
<ul>
<li>HSpec: …
<ul>
<li>hspec-hedgehog</li>
<li>hspec-laws:</li>
<li>hspec-smallcheck</li>
<li>hspec-leancheck</li>
<li>hspec-slow</li>
<li>hspec-test-framework (and hspec-test-framework-th)</li>
<li>hspec-multicheck</li>
<li>hspec-wai and -wai-json</li>
<li>hspec-megaparsec, -parsec, -attoparsec</li>
</ul></li>
<li>test-framework: comprises HUnit tests and QuickCheck properties in a single interface.
<ul>
<li>relatively actively maintained, as of writing this.</li>
<li>test-generator (aka test-framework-th) was last updated in 2012.</li>
</ul></li>
<li>HTF (Haskell Testing Framework): automatically collects individual unit tests (hspec-discover only finds modules)
<ul>
<li>unit tests (HUnit)</li>
<li>QuickCheck properties</li>
<li>black-box tests</li>
<li>custom preprocessor gathering test definitions automatically; failure with exact file name and line number.</li>
</ul></li>
<li>tasty (tasty-discover: TODO, archived??)
<ul>
<li>tasty-laws</li>
<li>tasty-lens</li>
<li>tasty-th</li>
<li>tasty-tmux</li>
<li>tasty-wai</li>
<li>tasty-travis</li>
<li>tasty-stats</li>
<li>tasty-hunit</li>
<li>tasty-hspec</li>
<li>tasty-hedgehog and -hedgehog-coverage</li>
</ul></li>
</ul>
<p>Essentially, HSpec and Tasty are the two major frameworks.</p>
<p>Benchmarking:</p>
<ul>
<li>Criterion</li>
<li>…</li>
</ul>
<p>We first will investigate unit testing with HUnit and property testing with QuickCheck. After this, we will cover the frameworks that comprise both approaches.</p>
<h1 id="testing-and-quality-assurance">Testing and Quality Assurance</h1>
<h2 id="fundamental-definitionstermsjargonlingo">Fundamental Definitions/Terms/Jargon/Lingo</h2>
<p>Test-driven design (TDD) of software: TODO</p>
<ul>
<li>Unit test (HUnit, tasty-hunit):</li>
<li>Golden test (tasty-golden): unit tests whose results are stored in files.</li>
<li>Property test (QuickCheck, SmallCheck, Hedgehog, LeanCheck): specify a property a function must adhere to, and test whether this is the case.</li>
<li>Regression test:</li>
</ul>
<p>A framework is aimed at gathering these individual groups of tests in a single uniform test expression that the compiler will evaluate for us, to inform us whether everything’s fine. It is crucial especially when introducing changes to pristine code. Anything could go wrong. Recall that Haskell’s advanced type system makes most bugs travel back in time and emerge at compile-time rather than the runtime, at which our users make their experience with our software. We want to make them happy and solve their problems, make their lives easier. Any runtime bug is an encumbrance on a user.</p>
<h2 id="typical-workflow">Typical Workflow</h2>
<p>So we have a two-step approach to ensuring this high quality of our products and services:</p>
<ol type="1">
<li>use Haskell to impose a high level of mandatory consistency, soundness, and correctness of our programs — nothing will compile that doesn’t meet that requirement (this imposes syntactic and logical correctness as expressed by types); and then additionally</li>
<li>test our programs thoroughly to ensure that we translated our ideas correctly into code — the compiler, GHC, will alert us whenever we specify that we want something different than what actually gets computed as a result (this imposes semantic and translational correctness as expressed by our test specifications).</li>
</ol>
<p>The Haskell ecosystem provides top-notch world-class quality assurance and testing facilities. It comes closest to formal verification, without the excessive burden and cost. It is a pragmatic gold standard of great quality of software. And should we indeed need to formally verify critical pieces of code, we’ve set the stage for it already. With Template Haskell, we can even attain automated test generation, including all the boilerplate potentially necessary. Moreover, we can use Haskell’s testing frameworks for other languages and platforms. We can also embed other languages in Haskell code and use it as our glue.</p>
<h2 id="examples">Examples</h2>
<!-- - embedded gists -->
<!-- - embedded binder instance cells -->

    </div>
    <div id="footer">
      <div id="hakyllReference">Compiled with <span class="redHeart">♥</span> by <a href="http://jaspervdj.be/hakyll">Hakyll</a></div>
      <!-- <i class="fas fa-heart redHeart"></i> -->
    </div>
  </body>
</html>
