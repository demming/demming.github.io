<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Nick Demming's blog</title>
    <link href="https://demming.github.io/atom.xml" rel="self" />
    <link href="https://demming.github.io" />
    <id>https://demming.github.io/atom.xml</id>
    <author>
        <name>Nick Demming</name>
        <email>nick.demming@gmail.com</email>
    </author>
    <updated>2020-04-30T00:00:00Z</updated>
    <entry>
    <title>The Software Testing Fallacy</title>
    <link href="https://demming.github.io/blog/2020/04/30/software-testing-fallacy-halting-problem-undecidable/index.html" />
    <id>https://demming.github.io/blog/2020/04/30/software-testing-fallacy-halting-problem-undecidable/index.html</id>
    <published>2020-04-30T00:00:00Z</published>
    <updated>2020-04-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[A quick leap from the undecidable halting problem through denotational semantics and straight to the caveats of software testing.]]></summary>
</entry>
<entry>
    <title>Functional C++ Juxtaposed with Haskell</title>
    <link href="https://demming.github.io/blog/2020/04/23/functional-cpp-haskell-object-oriented-paradigm/index.html" />
    <id>https://demming.github.io/blog/2020/04/23/functional-cpp-haskell-object-oriented-paradigm/index.html</id>
    <published>2020-04-23T00:00:00Z</published>
    <updated>2020-04-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="blog-post full">
  <header>
    <h1><a href="/blog/2020/04/23/functional-cpp-haskell-object-oriented-paradigm/index.html">Functional C++ Juxtaposed with Haskell</a></h1>
    <span class="subtitle">Cohabitation via Foreign-Function Interfaces and Inter-Process communication, Architecture, and Algorithms in C++ and Haskell</span>
  </header>
  <section class="post-meta internal-links">
    
    <time class="post-date">April 23, 2020</time>
    <span class="post-tags"><ul></ul></span>
  </section>
  <hr class="pre-content">
  <section class="post-content">
<div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#a-note-on-java"><span class="toc-section-number">1</span> A Note on Java</a></li>
<li><a href="#functional-paradigms"><span class="toc-section-number">2</span> Functional Paradigms</a></li>
<li><a href="#function-types"><span class="toc-section-number">3</span> Function Types</a></li>
<li><a href="#type-inference-generics-and-templates"><span class="toc-section-number">4</span> Type Inference, Generics, and Templates</a></li>
<li><a href="#evaluation-strategies-referential-transparency-immutable-data-purity-and-side-effects"><span class="toc-section-number">5</span> Evaluation Strategies, Referential Transparency, Immutable Data, Purity, and Side-Effects</a>
<ul>
<li><a href="#referential-transparency"><span class="toc-section-number">5.1</span> Referential Transparency</a></li>
<li><a href="#purity"><span class="toc-section-number">5.2</span> Purity</a></li>
</ul></li>
<li><a href="#when-should-i-use-which"><span class="toc-section-number">6</span> When Should I Use Which?</a></li>
</ul>
</div>
<p>There have been several attempts at reconciliation of the procedural (think Assembly or C), object-oriented (think C++ or Java) and the functional (think Haskell or Erlang) paradigms. Most prominent of them has arguably been Scala. I believe Scala is a very complex language but enjoys the benefit of the JVM ecosystem, which Eta and Frege also tried to achieve but were hit by JVM’s downside of garbage collection.  C++ is also a very complex language but provides the benefit of greater performance and direct memory control, without any dynamic garbage collection, reducing the memory footprint, so we can run our programs on microcontrollers with tiny memory such as network interface cards (NICs) so as to reduce latency in automated trading.</p>
<p>In this post we will focus on developing a first approach to functional programming in C++ and contrast the modern syntax, using the C++17 and C++20 standards.</p>
<h1 data-number="1" id="a-note-on-java" data-number="1"><span class="header-section-number">1</span> A Note on Java</h1>
<p>As for Java, it has undergone significant improvements, beginning with the introduction of Java 8, also embedding some functional-programming concepts. But Java is poised to remain a retrograde (in a good sense) language, always a few years if not decades behind its younger descendants such as Kotlin and Scala in the facilities it offers on the syntactic level.</p>
<p><em>Roughly</em>, <code>Haskell =&gt; Scala -&gt; Kotlin -&gt; Java</code>, where he arrows denote the flow of language and library features, on the JVM essentially originating in the Scala ecosystem acting as the melting pot of the FP and OOP fusion, with droplets trickling through into Kotlin, and only then filtered into Java the language; and Haskell’s ecosystem can be seen as the implementation origin of most if not all FP concepts (Lisp and Erlang are actually far more significant than most developers realize). We could also juxtapose C++ besides Haskell in that flow diagram as the originator of OOP concepts.</p>
<p>This is only intended as a mental picture, without any claim for ultimate correctness. In reality, everyone language community borrows something presumably good from another, in fact some things just work much better with one compiler than another, e.g., Haskell’s concepts are above and beyond more performant than their Scala implementations.</p>
<p>With the ascent of GraalVM and polyglot projects, the JVM ecosystem has entered its fruitful period of rejuvenation, bringing about significant results. Suffice it to mention Vert.x as the epitome of the progress already achieved.</p>
<p>Thanks to <a href="TODO"><code>inline-java</code></a> there is a wonderful compatibility layer between Haskell and Java (and the JVM). I’ll introduce you to it at a later time. Let’s now return to C++ and Haskell.</p>
<h1 data-number="2" id="functional-paradigms" data-number="2"><span class="header-section-number">2</span> Functional Paradigms</h1>
<p>In his book <a href="TODO">“Category Theory for Programmers”</a>, <em>Bartosz Milewski</em> already used C++ to introduce developers to category theory and Haskell. I highly recommend his book to the interested, but also its slight <a href="TODO">modification</a> that includes the corresponding Scala code. The approach I’m taking here will be different. We will focus on applications of category theory as approximated and implemented in Haskell libraries, only the most important parts of it that are relevant to the problems of software architecture that we will face, and start with practical Haskell, and see how we could write the same with the modern C++ libraries.</p>
<p>First off, we will only need to deal with the most basic FP concepts such as functor, applicative functor, monad, and lazy (or infinite) streams. If you need a recap, you’ll find a lot under the <a href="/tags/haskell/">tag “Haskell”</a> on my blog.</p>
<h1 data-number="3" id="function-types" data-number="3"><span class="header-section-number">3</span> Function Types</h1>
<p>In Haskell and PureScript, we define a function simply as <code>f :: a -&gt; b</code>, in papers, in Idris and Agda we use single colons for the type inhabitant relation, i.e., <code>f : a -&gt; b</code>. In TypeScript, we declare a function type as <code>function f (a: a, b: b): c</code>. In Python, it’s <code>def f(a: a, b: b) -&gt; c</code> with type annotations. And in Scala, it’s <code>def f(a: A, b: B): C</code>. All pretty clear and concise. But in C and its derivatives such as C++ and Java, the type is specified ahead of the variable name, i.e., <code>C f(A a, B b);</code> and there is no distinction between a type name and a variable name, wheres in Haskell the names live on different levels. But starting C++11, functions can also be declared more succinctly as <code>auto f(A a, B b) -&gt; C;</code> where the so-called “trailing type” <code>C</code> requires the “leading type” <code>auto</code>.[cppRudiments] In C#, it’s <code>Func&lt;A, B, C&gt; f</code>.</p>
<p>Let’s round this up by contrasting anonymous functions, lambda expression, or lambda abstractions, or even “<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/">delegates</a>” in C#. Suppose <code>f</code> is given as above.</p>
<ul>
<li><code>\a b -&gt; f a b</code> in Haskell and PureScript.</li>
<li><code>(a, b) =&gt; { f(a, b); }</code> in JavaScript starting with ECMAScript 6, in TypeScript, and in Scala (capturing nontrivial and depends on <code>strict</code>).</li>
<li><code>lambda a b: f(a, b)</code> in Python (note the capture of outer-scope vars in Python 2).</li>
<li><code>[&amp;](auto a, auto b) { f(a, b) }</code> in C++11 (with explicit outer-scope capture specification).</li>
<li><code>(a, b) =&gt; f(a, b)</code> in C# (outer-scope capture), but C# is far from making FP easy, but given F# the lack of push is apparent.</li>
</ul>
<h1 data-number="4" id="type-inference-generics-and-templates" data-number="4"><span class="header-section-number">4</span> Type Inference, Generics, and Templates</h1>
<p>Haskell, Agda and Idris shine when it comes to automated type inference, more so under their vastly advanced type systems.</p>
<p>Haskell also provides both generics and templates, as C++ does. And C++11 introduced automated type inference which can be invoked with the <code>auto</code> type specification.</p>
<h1 data-number="5" id="evaluation-strategies-referential-transparency-immutable-data-purity-and-side-effects" data-number="5"><span class="header-section-number">5</span> Evaluation Strategies, Referential Transparency, Immutable Data, Purity, and Side-Effects</h1>
<p>Given an expression, it must be evaluated in order to obtain the value that is represents. With lazy evaluation, an expression is reduced to its normal form by-need and only as far as needed at a computational step. In fact, its lazy-by-default evaluation sets Haskell apart among the vast variety of languages. However, it makes reasoning about space complexity harder in general. On the other hand, it enables powerful structural reductions, where the compiler simply omits many otherwise necessarily executed computational steps, and leaves only an expression that is much much easier to compute and evaluate. This is huge!</p>
<h2 data-number="5.1" id="referential-transparency" data-number="5.1"><span class="header-section-number">5.1</span> Referential Transparency</h2>
<p>An expression is said to be <strong>referentially transparent</strong> if it is amenable to substitution by its value or its (weak-head) normal form, anytime and everywhere, without introducing any change to the result of the program. In other words, we have just a rewrite system.</p>
<p>As noted above, this gives us a perfect foundation for software verification, refactoring, optimization, memoization, and parallelization. It also enables lazy evaluation in the first place.</p>
<p>For a better understanding, a <strong>referent</strong> of an expression is the semantic object that it represents, a meaning, a value. And referential transparency of an expression <code>x</code> therefore means that whenever we replace one subexpression <code>y</code> for a referent with another expression <code>z</code> for the same referent, the meaning that <code>x</code> represents will not change. For example, in process of reduction to the WHNF, we can simply take the expression at every step and substitute it for the original <code>y</code>. Here’s a catamorphism example for lists in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">foldr</span> _ b []     <span class="ot">=</span> b</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="fu">foldr</span> f b (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">foldr</span> f (x <span class="ot">`f`</span> b) xs</span></code></pre></div>
<p>So for <code>f = (:) :: a -&gt; [a] -&gt; [a]</code>, where <code>b ~ [a]</code>,</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">foldr</span> f   [<span class="dv">0</span>] [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">==</span> <span class="fu">foldr</span> f (<span class="dv">1</span> <span class="ot">`f`</span> [<span class="dv">0</span>]) [<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">==</span> <span class="fu">foldr</span> f (<span class="dv">2</span> <span class="ot">`f`</span> (<span class="dv">1</span> <span class="ot">`f`</span> [<span class="dv">0</span>])) [<span class="dv">3</span>] <span class="op">==</span> <span class="fu">foldr</span> f (<span class="dv">3</span> <span class="ot">`f`</span> (<span class="dv">2</span> <span class="ot">`f`</span> (<span class="dv">1</span> <span class="ot">`f`</span> [<span class="dv">0</span>]))) [] <span class="op">==</span> <span class="dv">3</span> <span class="ot">`f`</span> (<span class="dv">2</span> <span class="ot">`f`</span> (<span class="dv">1</span> <span class="ot">`f`</span> [<span class="dv">0</span>]))</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="fu">foldr</span> (<span class="op">:</span>) [<span class="dv">0</span>] [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">==</span> <span class="fu">foldr</span> (<span class="op">:</span>)   (<span class="dv">1</span><span class="op">:</span>[<span class="dv">0</span>]) [<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">==</span> <span class="fu">foldr</span> (<span class="op">:</span>) (<span class="dv">2</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span>[<span class="dv">0</span>]) [<span class="dv">3</span>]         <span class="op">==</span> <span class="fu">foldr</span> (<span class="op">:</span>) (<span class="dv">3</span><span class="op">:</span><span class="dv">2</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span>[<span class="dv">0</span>]) []               <span class="op">==</span> [<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">0</span>]</span></code></pre></div>
<h2 data-number="5.2" id="purity" data-number="5.2"><span class="header-section-number">5.2</span> Purity</h2>
<p>Formally, a (not necessarily in mathematical sense proper) function is said to be <strong>pure</strong> if the function evaluates to the same result for every combination of arguments, under all states of the world, and thereby does not produce any side-effects.</p>
<h3 data-number="5.2.1" id="same-result" data-number="5.2.1"><span class="header-section-number">5.2.1</span> Same result</h3>
<p>Let’s dissect this definition. So first of all, under all states of the world, for every set of argument values, the function must evaluate to the same result. In symbols, suppose <code>x : a</code> represents the collection of arguments to our function <code>f : a -&gt; b</code>, but it also depends on the state of the world, <span class="math inline">\(\omega \in \Omega\)</span>. We could also say that this function is said to be measurable if we endow <span class="math inline">\(\Omega\)</span> and the set representing our type <code>b</code> with <span class="math inline">\(\sigma\)</span>-algebras, or just the exponential object <span class="math inline">\(b^a\)</span>, and consider this <code>f</code> as a random process or random field, but this would lead us astray if it already hasn’t.</p>
<p>So let’s just stay with <code>f : a -&gt; b</code> and state that, regardless of the state of the world, which is beyond the reach of <code>f</code> and includes all static variables, global (i.e., non-local) variables which can but need not be controlled by the caller of <code>f</code>, any mutable reference arguments, and even streaming data from however-random IO devices such as the file system or simply the keyboard.</p>
<h3 data-number="5.2.2" id="no-side-effects" data-number="5.2.2"><span class="header-section-number">5.2.2</span> No side-effects</h3>
<h3 data-number="5.2.3" id="explanation" data-number="5.2.3"><span class="header-section-number">5.2.3</span> Explanation</h3>
<p>Purity is not limited to Haskell. C++ functions can also be pure. All we need to do is avoid mutable state and mutable data.</p>
<p>Purity essentially amounts to absence of state mutation and to immutable data.</p>
<p>Purity means that a function produces no side-effects; this is a guarantee of predictable behavior. Essential purity means that a function may semantically produce side effects but syntactically this is represented by a side-effects modeling type, such as <code>IO a</code> or <code>Writer w a</code>. The function does nothing until its monadic value gets evaluated. Until then it “lazily” defines what it is.</p>
<p>In Haskell, all functions are pure or essentially pure and there’s only one interface to the <code>RealWorld</code> — via <code>IO</code>. In C++ in contrast functions are impure or essentially impure.</p>
<p>Here’s a pure function in C++, with <code>using std::atomic;</code></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">auto</span> f() -&gt; <span class="dt">void</span> {</span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="at">static</span> atomic&lt;uint32&gt; x = <span class="dv">0</span>;   <span class="co">// </span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  x = x + <span class="dv">1</span>;                     <span class="co">// Or just x += 1, or x++.</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>}</span></code></pre></div>
<p>Impurity means that a function can change a global state, and this is not signified in its type signature. Essential impurity means that we can define a function to be “pure,” i.e., avoid any side-effects, but the language and its type system do not give us such a guarantee. For example,</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">void</span> f(<span class="dt">int</span>, <span class="at">const</span> <span class="dt">int</span> (&amp;)[<span class="dv">2</span>] = {}) {}</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="dt">void</span> g() {</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="dt">int</span> x = <span class="dv">17</span>;</span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">auto</span> g1 = [](<span class="kw">auto</span> a)  { x += a; f(x); };  <span class="co">// Calls #1, does capture x.</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="kw">auto</span> g2 = [=](<span class="kw">auto</span> a) { f(x); };          <span class="co">// Does not capture x in C++14, captures x in C++17.</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>}</span></code></pre></div>
<p>But how would we know that <code>f</code> would not modify its argument <code>x</code>? In Haskell we know for sure, while in C++ we can’t without looking carefully at <code>f</code> and the name scopes. What if <code>x</code> also is a dependent variable, determined by some impure computation and all states altered are intertwined? This downside of impure languages makes reasoning very hard and regular debugging almost necessary. Static code analyzers and linters can help a bit. The greater the benefit of functional concepts introduced to C++.</p>
<p>Here’s another <a href="https://en.cppreference.com/w/cpp/language/lambda">example</a>, in C++14,</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">int</span> x = <span class="dv">4</span>;</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">auto</span> y = [&amp;r = x, x = x + <span class="dv">1</span>]() -&gt; <span class="dt">int</span> {</span>
<span id="cb5-3"><a href="#cb5-3"></a>    r += <span class="dv">2</span>;</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="cf">return</span> x * x;</span>
<span id="cb5-5"><a href="#cb5-5"></a>  }(); <span class="co">// updates ::x to 6 and initializes y to 25.</span></span></code></pre></div>
<p>When you have a mental picture of memory registers that you access and the program remains simple enough to quickly retrace every impure state modification, it might be fine. But the larger the project grows, and the more people are involved on a team, and the more features get introduced, the greater the risk of irreparable damage done by benign changes. This is where continuous integration and quality assurance come into play. But all these efforts can be subsumed by simply using a more advanced type system like Haskell’s. Regardless, C++ has its unmatched benefits.</p>
<p>The issues highlighted above can be summarized as the lacking of referential transparency.</p>
<h1 data-number="6" id="when-should-i-use-which" data-number="6"><span class="header-section-number">6</span> When Should I Use Which?</h1>
<p>This question is good and simple to answer: it depends on your project requirements and the team cost–benefit trade-off. By project requirements I mean whether you need easy integration, high performance, rapid delivery, low maintenance, but also the deadlines and the budget. By the cost–benefit trade-off I refer to skills and experience of your team.</p>
<p>For example, if you know that your target platform depends on the JVM ecosystem, it’s smart to implement your business logic in a JVM-native language while using the JDK libraries. With polyglot and GraalVM there are huge boons available now. If you know that you need to deal with mostly high-performance code without regard to its runtime environment and your team knows how to manage the memory, go for C++ (or perhaps Rust if it’s not too avant-garde for you).</p>
<p>In essence, whenever you feel you need more control of your memory and don’t trust the garbage collector of the runtime platform, go for C++.</p>
<p>In practice, when writing Haskell, you sit and ponder about what you want to accomplish, perhaps even sketch some hopefully commuting diagrams with pen and paper, and then simply write it down in Haskell, and the compiler tells you whether this makes sense, curiously you’re usually mostly correct. In contrast, when writing C++, you imagine the procedures that hopefully meticulously describe the evolution of the state of your system, and prescribe the actions in each step, provoking you to rush into the battle so to say, the compiler helps you with the syntax and some metaprogramming typos but when it comes down to the system architecture, it will remain silent — in contrast with Haskell’s compiler. In this sense these are really two different worlds. In C++ and other imperative languages you have to leverage your testing skills, trying <em>heuristically</em> to ensure compliance with the specification, whereas in Haskell you simply encode the specification as types and let the compiler ensure that you preserve conformance with the spec, and only then do you add tests to ensure that your model implementation corresponds to your model logic. The state of the mind is different. With C++ you’re focused on managing an inherently imperative or procedural memory model, whereas with Haskell you manage a functional architecture.</p>
<p>Writing Haskell is akin to coding against a spec, essentially a form of test-driven development. Maybe this is what makes it uneasy to start with for many developers not used to testing but those who are used to testing seem to take up Haskell in a whim. A good approach to starting a new Haskell project is just to begin with the architecture; once you know what the inputs and the outputs of your project are and how you’re going to process the data, start writing down the individual functions with their types and leaving the function body <code>undefined</code>. Once the project skeleton is set up, it’s time to start filling the gaps, one by one, any way you feel most comfortable with. When done, only then is it time to look around what you have and refactor pieces of your code in any abstract profunctors and what not that you still understand. This will also help the compiler understand your actual intentions. You don’t have to do everything at once, just run a quick sanity and coherence check; and after a first swoop, it’s time for testing with HSpec, HUnit, and QuickCheck — choose any framework that you like (see <a href="..">my post on testing in Haskell</a>). When your test suite is complete, take a second swoop at refactoring and make sure to run tests after each refactoring, if you have an automated build pipeline (CI/CD), it’s a breeze to implement. That way, you have all your essential business logic encoded in types, the test suite guarantees certain invariants, and you are free to roam in the category-theoretic realm of abstract nonsense and perhaps express some clunky piece of code that is hard to read for others on your team into something agreed upon — but you should first mutually agree on the maximal level of abstraction and discuss the individual notions that you decide to choose. Make also sure to establish a benchmarking suite. With Stack or directly with Cabal it is fairly straightforward.  It’s not hard at all, just don’t start with the very abstract ideas, and rather consider them as an optimization step. In my experience, working with Haskell occurs to some 90% on the type level, not the term level as with almost every other programming languages.</p>
<p>Haskell is perfect for software architecture, quality assurance, prototyping and high-performance parallel computations. My approach is to implement everything in Haskell first, so as to have a great prototype; then I perform tests and run benchmarks, and if I see no other way to improve performance and it is crucial, I just turn to IPC with C++ and write some API bindings for Haskell. This has long been popular with “Python as a glue” approach. By the way, Numba is phenomenal (Julia’s JIT is awesome too).</p>
<p>In short, there are different situations in which one language and its ecosystem or another one fits best the bill.</p></section>
</article>

<!-- <div id="disqus-thread"></div> -->
<!-- <script> -->
<!--   var disqus_config = function () { -->
<!--       this.page.identifier = '2020-04-23-functional-cpp-haskell-object-oriented-paradigm'; -->
<!--   }; -->

<!--   (function () { -->
<!--       var d = document, s = d.createElement('script'); -->
<!--       s.src = 'https://demming.disqus.com/embed.js'; -->
<!--       s.setAttribute('data-timestamp', +new Date()); -->
<!--       (d.head || d.body).appendChild(s); -->
<!--   })(); -->
<!-- </script> -->
<!-- <noscript> -->
<!--     To view the --> 
<!--     <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a> -->
<!--     you need to enable JavaScript in your browser. -->
<!-- </noscript> -->
]]></summary>
</entry>
<entry>
    <title>On the Updated Design of My Blog</title>
    <link href="https://demming.github.io/blog/2020/04/12/blog-webdesign-javascript-css-typescript/index.html" />
    <id>https://demming.github.io/blog/2020/04/12/blog-webdesign-javascript-css-typescript/index.html</id>
    <published>2020-04-12T00:00:00Z</published>
    <updated>2020-04-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="blog-post full">
  <header>
    <h1><a href="/blog/2020/04/12/blog-webdesign-javascript-css-typescript/index.html">On the Updated Design of My Blog</a></h1>
    <span class="subtitle">Now with some CSS and JavaScript</span>
  </header>
  <section class="post-meta internal-links">
    
    <time class="post-date">April 12, 2020</time>
    <span class="post-tags"><ul></ul></span>
  </section>
  <hr class="pre-content">
  <section class="post-content">
<div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#motivation"><span class="toc-section-number">1</span> Motivation</a></li>
<li><a href="#vanilla-hakyll"><span class="toc-section-number">2</span> Vanilla Hakyll</a></li>
<li><a href="#issues-arising"><span class="toc-section-number">3</span> Issues Arising</a>
<ul>
<li><a href="#mobile-friendly"><span class="toc-section-number">3.1</span> Mobile-Friendly</a></li>
<li><a href="#accessibility-friendly-screenreaders-etc."><span class="toc-section-number">3.2</span> Accessibility-Friendly (Screenreaders etc.)</a></li>
<li><a href="#state-of-the-javascript-ecosystem"><span class="toc-section-number">3.3</span> State of the JavaScript Ecosystem</a></li>
</ul></li>
<li><a href="#modern-front-end"><span class="toc-section-number">4</span> Modern Front End</a></li>
<li><a href="#choice-of-the-build-tools-and-the-lifecycle-management"><span class="toc-section-number">5</span> Choice of the Build Tools and the Lifecycle Management</a></li>
<li><a href="#choice-of-a-front-end-compiler-ghcjs-vs-purescript-vs-elm-vs-reasonml-vs-typescript-vs-javascript"><span class="toc-section-number">6</span> Choice of a Front-end Compiler: GHCJS vs PureScript vs Elm vs ReasonML vs TypeScript vs JavaScript</a></li>
<li><a href="#outro"><span class="toc-section-number">7</span> Outro</a></li>
</ul>
</div>
<p>In this post I’m quickly describing my efforts to theme a plain vanilla Hakyll front end.</p>
<h1 data-number="1" id="motivation" data-number="1"><span class="header-section-number">1</span> Motivation</h1>
<p>Hakyll comes with a very basic plain black-and-white theme in paper style. Thanks to Pandoc, code blocks have all the markup, but it remains ignored initially. In what comes next I will describe how I’ve realized the present design. Gotta take some screenshots for comparison…</p>
<h1 data-number="2" id="vanilla-hakyll" data-number="2"><span class="header-section-number">2</span> Vanilla Hakyll</h1>
<h1 data-number="3" id="issues-arising" data-number="3"><span class="header-section-number">3</span> Issues Arising</h1>
<h2 data-number="3.1" id="mobile-friendly" data-number="3.1"><span class="header-section-number">3.1</span> Mobile-Friendly</h2>
<h2 data-number="3.2" id="accessibility-friendly-screenreaders-etc." data-number="3.2"><span class="header-section-number">3.2</span> Accessibility-Friendly (Screenreaders etc.)</h2>
<h2 data-number="3.3" id="state-of-the-javascript-ecosystem" data-number="3.3"><span class="header-section-number">3.3</span> State of the JavaScript Ecosystem</h2>
<h1 data-number="4" id="modern-front-end" data-number="4"><span class="header-section-number">4</span> Modern Front End</h1>
<h1 data-number="5" id="choice-of-the-build-tools-and-the-lifecycle-management" data-number="5"><span class="header-section-number">5</span> Choice of the Build Tools and the Lifecycle Management</h1>
<p>Build automation is a boon. On this tiny scale of a blog, at first setting up a proper dev environment with a good pipeline is an effort not worth hassle. But as the complexity will rise, I will adopt more lifecycle management and automation tools, and blog about them.</p>
<p>For now, I’ve come to use Gulp + Babel + TypeScript + Parcel.</p>
<p>Next I’m planning to create a CV route, improve the interaction, adopt Stencil to create good web components, so in the end this blog looks and feels like a mobile app, and make it a proper PWA.</p>
<h1 data-number="6" id="choice-of-a-front-end-compiler-ghcjs-vs-purescript-vs-elm-vs-reasonml-vs-typescript-vs-javascript" data-number="6"><span class="header-section-number">6</span> Choice of a Front-end Compiler: GHCJS vs PureScript vs Elm vs ReasonML vs TypeScript vs JavaScript</h1>
<p>A thorough comparison deserves a separate post. Stay tuned. But for now, since I don’t yet need a full-fledged front end, there’s no reason to</p>
<h1 data-number="7" id="outro" data-number="7"><span class="header-section-number">7</span> Outro</h1>
<p>I must admit, it has been a lot of fun. Modern front end development is a joy. And despite all the chaos in its ecosystem, choices can be made. This is in fact crucial.</p>
<p>Plans for the next couple of weeks:</p>
<ul class="task-list">
<li><input type="checkbox" disabled="" />
Nitpicking on the design.</li>
<li><input type="checkbox" disabled="" />
Make Haskell’s Sass library work with the Dart implementation that supports the more modern features.</li>
<li><input type="checkbox" disabled="" />
Fix MathJax CDN errors due to the same-origin policy.</li>
<li><input type="checkbox" disabled="" />
Fix MathJax CDN choice of fonts.</li>
<li><input type="checkbox" disabled="" />
Improve the sidebar.</li>
<li><input type="checkbox" disabled="" />
Implement dark-mode.</li>
<li><input type="checkbox" disabled="" />
Implement sharing facilities.</li>
<li><input type="checkbox" disabled="" />
Some quality posts.</li>
<li><input type="checkbox" disabled="" />
Introduce D3.js data visualizations, including tag clouds and word cloud summaries.</li>
</ul></section>
</article>

<!-- <div id="disqus-thread"></div> -->
<!-- <script> -->
<!--   var disqus_config = function () { -->
<!--       this.page.identifier = '2020-04-12-blog-webdesign-javascript-css-typescript'; -->
<!--   }; -->

<!--   (function () { -->
<!--       var d = document, s = d.createElement('script'); -->
<!--       s.src = 'https://demming.disqus.com/embed.js'; -->
<!--       s.setAttribute('data-timestamp', +new Date()); -->
<!--       (d.head || d.body).appendChild(s); -->
<!--   })(); -->
<!-- </script> -->
<!-- <noscript> -->
<!--     To view the --> 
<!--     <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a> -->
<!--     you need to enable JavaScript in your browser. -->
<!-- </noscript> -->
]]></summary>
</entry>
<entry>
    <title>Functors in Haskell</title>
    <link href="https://demming.github.io/blog/2020/03/31/haskell-functors/index.html" />
    <id>https://demming.github.io/blog/2020/03/31/haskell-functors/index.html</id>
    <published>2020-03-31T00:00:00Z</published>
    <updated>2020-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="blog-post full">
  <header>
    <h1><a href="/blog/2020/03/31/haskell-functors/index.html">Functors in Haskell</a></h1>
    <span class="subtitle">A categorically motivated basic building block in functional programming</span>
  </header>
  <section class="post-meta internal-links">
    
    <time class="post-date">March 31, 2020</time>
    <span class="post-tags"><ul><li><a href="/tags/category%20theory/index.html">category theory</a></li><li><a href="/tags/functor/index.html">functor</a></li><li><a href="/tags/haskell/index.html">haskell</a></li><li><a href="/tags/natural%20transformation/index.html">natural transformation</a></li><li><a href="/tags/pattern/index.html">pattern</a></li></ul></span>
  </section>
  <hr class="pre-content">
  <section class="post-content">
<div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#functorial-structure"><span class="toc-section-number">1</span> Functorial Structure</a></li>
<li><a href="#composition-or-superposition-of-functorial-structures"><span class="toc-section-number">2</span> Composition or Superposition of Functorial Structures</a></li>
<li><a href="#implementations-for-maybe-and"><span class="toc-section-number">3</span> Implementations for <code>Maybe</code> and <code>[]</code></a>
<ul>
<li><a href="#a-functor-instance-for-maybe"><span class="toc-section-number">3.1</span> A <code>Functor</code> instance for <code>Maybe</code></a></li>
<li><a href="#a-functor-instance-for-lists"><span class="toc-section-number">3.2</span> A <code>Functor</code> instance for lists, <code>[]</code></a></li>
</ul></li>
<li><a href="#other-standard-data-types"><span class="toc-section-number">4</span> Other Standard Data Types</a>
<ul>
<li><a href="#sum-and-product-types"><span class="toc-section-number">4.1</span> Sum and Product Types</a></li>
<li><a href="#function-type--"><span class="toc-section-number">4.2</span> Function Type <code>(-&gt;)</code></a></li>
<li><a href="#reader-writer-and-state-monads"><span class="toc-section-number">4.3</span> Reader, Writer, and State Monads</a></li>
</ul></li>
<li><a href="#key-take-aways"><span class="toc-section-number">5</span> Key Take-Aways</a></li>
<li><a href="#bonus-material"><span class="toc-section-number">6</span> Bonus Material</a>
<ul>
<li><a href="#somewhat-esoteric-functor-instances"><span class="toc-section-number">6.1</span> Somewhat Esoteric Functor Instances</a></li>
<li><a href="#natural-transformations"><span class="toc-section-number">6.2</span> Natural Transformations</a></li>
</ul></li>
</ul>
</div>
<h1 data-number="1" id="functorial-structure" data-number="1"><span class="header-section-number">1</span> Functorial Structure</h1>
<p>In category theory, a functor <span class="math inline">\(F: C \to D\)</span> between categories <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span> is</p>
<ol type="1">
<li>an assignment
<ol type="i">
<li>to objects <span class="math inline">\(a\)</span> in <span class="math inline">\(C\)</span> of objects <span class="math inline">\(F a\)</span> in <span class="math inline">\(D\)</span> and</li>
<li>to arrows <span class="math inline">\(f : a \to b\)</span> of arrows <span class="math inline">\(Ff : Fa \to Fb\)</span> in <span class="math inline">\(D\)</span>,</li>
</ol></li>
<li>such that the laws of
<ol type="i">
<li>identity: <span class="math inline">\(F : \operatorname{id}_a = \operatorname{id}_{Fa}\)</span>, for all objects <span class="math inline">\(a\)</span> in <span class="math inline">\(C\)</span>, and</li>
<li>composition: <span class="math inline">\(F(g \circ f) = Fg \circ Ff\)</span>, for all (composable) morphisms <span class="math inline">\(f : a \to b\)</span> and <span class="math inline">\(g : b \to c\)</span> in <span class="math inline">\(C\)</span>,</li>
</ol>
are satisfied.</li>
</ol>
<p>Functors can also be considered as objects or as morphisms between objects. Indeed, in the category of categories, functors are morphisms, while in the category of functors, functors are objects, with natural transformations between them as the morphisms.</p>
<p>This categorical notion carries over to Haskell and justifies the choice of the name of the corresponding typeclass. Indeed,</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">class</span> <span class="dt">Functor</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</span></code></pre></div>
<p>which means that <code>f</code> is a type constructor of kind <code>* -&gt; *</code> or <code>Type -&gt; Type</code> the parentheses in <code>(f a -&gt; f b)</code> are syntactically superfluous due to right-associativity of the arrow <code>-&gt;</code> (it’s <code>infixr 0 -&gt;</code>), and which is such that the identity law</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">fmap</span> <span class="fu">id</span> <span class="op">==</span> <span class="fu">id</span></span></code></pre></div>
<p>and the composition law</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f <span class="op">==</span> <span class="fu">fmap</span> (g <span class="op">.</span> f)</span></code></pre></div>
<p>are satisfied. This must be verified manually but can be automated by black-box (structural or property) testing with, e.g., QuickCheck.</p>
<p>The essence of the <code>Functor</code> typeclass is that its <code>fmap</code> functor preserves the structure of the functorial value <code>x :: f a</code> it acts on. From the type signature of <code>fmap</code> it is obvious that it does not know anything about <code>f</code> as such. All it gets as input is an arbitrary functorial value <code>x</code> of type <code>f a</code>. To be more precise, with the GHC extension <code>ExplicitForAll</code>, we can correctly specify</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">  fmap ::</span> <span class="kw">forall</span> f a b<span class="op">.</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</span></code></pre></div>
<p>The identity law gives us the consistent assignment of objects to objects.</p>
<p>In other words, <code>fmap</code> can be considered as structure-preserving lifting. It even must preserve the length of a list, <code>[a]</code>, which also is a <code>Functor</code>. Just note that those types <code>f a</code> and <code>f b</code> can be functorial, too. In other words, <code>fmap</code> would take a function (morphism in one category) <code>f a -&gt; f b</code> and map it to a function (morphism in another category) <code>g (f a) -&gt; g (f b)</code>. But the types represented by the type variables <code>a</code> and <code>b</code> have nothing to do with the functorial structure of the type constructor <code>f :: * -&gt; *</code>, as any type is good for it. Let’s get a bit deeper into this nesting of functorial structures that we’ve just discovered.</p>
<p>As a remark, <code>(&lt;$&gt;) = fmap</code> with <code>infixl 4 &lt;$&gt;</code>, i.e., <code>&lt;$&gt;</code> is the infix synonym for <code>fmap</code>, associative to the left of precedence order <code>4</code>. Another side note is the regular confusion that arises due to the use of the letter <code>f</code> for the functorial type constructor and for the function-type argument to <code>fmap</code>. They live on different levels of the syntax, the former lives on the type level (types have kinds, akin “types of types”), whereas the latter on the term level (terms inhabit types).</p>
<h1 data-number="2" id="composition-or-superposition-of-functorial-structures" data-number="2"><span class="header-section-number">2</span> Composition or Superposition of Functorial Structures</h1>
<p>As usual, given an abstract notion, different perspectives let us discover new applications. Nesting of functorial structure is just one application of the categorical notion carried over to Haskell. Now, how do we express that nested <code>fmap</code> above? By just giving <code>a ~ f c</code> and <code>b ~ f d</code>,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> where <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> are arbitrary types and <code>f</code> is a functorial type constructor<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<p>But how can we go a step further and lift a function <code>j :: a -&gt; b</code> to a function of type <code>g (f a) -&gt; g (f b)</code> or even <code>k (h (g (f a))) -&gt; k (h (g (f b)))</code>? It turns out, just by composition of <code>fmap</code>s. Here’s how we do this.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">(.)         ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) </span>
<span id="cb5-3"><a href="#cb5-3"></a>            <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (g (f a) <span class="ot">-&gt;</span> g (f b))</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Functor</span> h) </span>
<span id="cb5-5"><a href="#cb5-5"></a>            <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (h (g (f a)) <span class="ot">-&gt;</span> h( g (f b)))</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Functor</span> h, <span class="dt">Functor</span> k) </span>
<span id="cb5-7"><a href="#cb5-7"></a>            <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (k (h (g (f a))) <span class="ot">-&gt;</span> k (h( g (f b))))</span></code></pre></div>
<p>Another question: when would we need this? Let’s take two of the simplest <code>Functor</code> instances, <code>Maybe</code> (free structure<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> on computations that can fail) and <code>[]</code> (non-deterministic computations<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>). Imagine we have a pure function <code>j :: a -&gt; b</code> that performs a trivial transformation, say <code>j = const 'j'</code>, where <code>const :: a -&gt; b -&gt; a</code> can do only one thing, namely take a value of type <code>a</code>, ignore the second argument of type <code>b</code>, and result in that same first argument; indeed this is completely encoded in the type signature: <code>const</code> expects a value of an arbitrary type <code>a</code>, it doesn’t know which concrete type the type variable <code>a</code> is until it’s bound, so it can’t use any class methods absent any type constraints, and it must result in a value of that same type <code>a</code>, hence it can only act as <code>id :: a -&gt; a</code> on the first argument and cannot process the second one of a potentially different type <code>b</code>.</p>
<p>Now imagine we have a value <code>x :: [Maybe Char]</code> such as <code>[Just 'c', Nothing]</code>. First note that both <code>[] :: * -&gt; *</code> and <code>Maybe :: * -&gt; *</code> are <code>Functor</code> instances. We have therefore a nested functorial structure here, which we can write as <code>g (f a)</code> where <code>g ~ []</code> and <code>f ~ Maybe</code>. So there are two levels of nesting. How about a value <code>y :: [Maybe String]</code> such as <code>[Just "cd", Nothing]</code>? It’s different now, since <code>type String = [Char]</code> by definition, which gives one deeper level of functorial nesting and is a structure <code>g (f (h a))</code> where <code>h ~ []</code>. And if we add a <code>Maybe</code> encapsulation, say, to obtain a value <code>z = Just y</code>, we’ll end up with <code>k (g (f (h a)))</code> where <code>k ~ Maybe</code>. Let’s see how this plays out.</p>
<p>So now we have</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>x <span class="ot">=</span> [<span class="dt">Just</span> <span class="ch">&#39;c&#39;</span>,  <span class="dt">Nothing</span>]<span class="ot"> ::</span> [<span class="dt">Maybe</span> <span class="dt">Char</span>]</span>
<span id="cb6-2"><a href="#cb6-2"></a>y <span class="ot">=</span> [<span class="dt">Just</span> <span class="st">&quot;cd&quot;</span>, <span class="dt">Nothing</span>]<span class="ot"> ::</span> [<span class="dt">Maybe</span> <span class="dt">String</span>] <span class="op">~</span> [<span class="dt">Maybe</span> [<span class="dt">Char</span>]]</span>
<span id="cb6-3"><a href="#cb6-3"></a>z <span class="ot">=</span> <span class="dt">Just</span><span class="ot"> y               ::</span> <span class="dt">Maybe</span> [<span class="dt">Maybe</span> <span class="dt">String</span>]</span></code></pre></div>
<p>We first apply our constant <code>j :: a -&gt; Char</code> directly to each of the three values. In the comments I specify the concrete type of <code>j</code> and what this <code>a</code> is, for each of those three values, <code>x</code>, <code>y</code> and <code>z</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>j x <span class="ot">=</span> <span class="ch">&#39;j&#39;</span>                    <span class="co">-- j :: a ~ [Maybe Char]         -&gt; Char</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>j y <span class="ot">=</span> <span class="ch">&#39;j&#39;</span>                    <span class="co">-- j :: a ~ [Maybe String]       -&gt; Char</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>j z <span class="ot">=</span> <span class="ch">&#39;j&#39;</span>                    <span class="co">-- j :: a ~ Maybe [Maybe String] -&gt; Char</span></span></code></pre></div>
<p>Now, let’s lift <code>j</code> to the context of the first level of the nesting.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="fu">fmap</span> j x <span class="ot">=</span> [<span class="ch">&#39;j&#39;</span>, <span class="ch">&#39;j&#39;</span>]        <span class="co">-- j :: a ~ Maybe Char     -&gt; Char</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="fu">fmap</span> j y <span class="ot">=</span> [<span class="ch">&#39;j&#39;</span>, <span class="ch">&#39;j&#39;</span>]        <span class="co">-- j :: a ~ Maybe String   -&gt; Char</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="fu">fmap</span> j z <span class="ot">=</span> <span class="dt">Just</span> <span class="ch">&#39;j&#39;</span>          <span class="co">-- j :: a ~ [Maybe String] -&gt; Char</span></span></code></pre></div>
<p>Let’s go one level deeper,</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>ff <span class="ot">=</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>ff j x <span class="ot">=</span> [<span class="dt">Just</span> <span class="ch">&#39;j&#39;</span>, <span class="dt">Nothing</span>]  <span class="co">-- j :: a ~ Char         -&gt; Char</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>ff j y <span class="ot">=</span> [<span class="dt">Just</span> <span class="ch">&#39;j&#39;</span>, <span class="dt">Nothing</span>]  <span class="co">-- j :: a ~ String       -&gt; Char</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>ff j z <span class="ot">=</span> <span class="dt">Just</span> <span class="st">&quot;jj&quot;</span>            <span class="co">-- j :: a ~ Maybe String -&gt; Char, so ff j :: (a -&gt; Maybe String) -&gt; f a -&gt; f Char</span></span></code></pre></div>
<p>The pattern is apparent: for <code>j</code>, we peel off one outer layer after another. This is because</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>ff <span class="ot">=</span> <span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (g (f a) <span class="ot">-&gt;</span> g (f b))</span></code></pre></div>
<p>whereby if <code>j :: a -&gt; b</code>, where <code>b ~ Char</code>, and</p>
<ul>
<li><p><code>x :: g (f a) ~ [Maybe Char]</code>, then necessarily <code>g ~ []</code> and <code>f ~ Maybe</code>, and hence <code>a ~ Char</code>, and therefore <code>j :: Char -&gt; Char</code>, and the curried application of <code>fmap . fmap</code> to <code>j</code> results in a function of type <code>Char -&gt; g (f b) ~ [Maybe Char]</code>;</p></li>
<li><p><code>y :: g (f a) ~ [Maybe String]</code>, then necessarily <code>g ~ []</code> and <code>f Maybe</code>, and hence <code>a ~ String</code>, and therefore we must have <code>j :: String -&gt; Char</code> and <code>fmap . fmap $ j :: String -&gt; g (f b) ~ [Maybe Char]</code>;</p></li>
<li><p><code>z :: g (f a) ~ Maybe [Maybe String]</code>, then necessarily <code>g ~ Maybe</code>, <code>f ~ []</code> and <code>a ~ Maybe String</code>, whereby <code>j :: Maybe String -&gt; Char</code> and <code>fmap .fmap $ j :: Maybe [Maybe String] -&gt; g (f b) ~ Maybe [Char] = Maybe String</code>.</p></li>
</ul>
<p>Such a proof can be referred to as manual or explicit <strong>type inference</strong>. This is one of Haskell and its compilers’ strengths. We never need to do this, that’s the compiler’s job. But we may want to do this to justify a refactorization, the introduction of a new abstraction to our code, or the correctness of an instance definition for a type constructor (including nullary type constructors which are equivalent to concrete or proper types). The more experience we gain with explicit type inference, the more easily can we reason about our code. So this is an excellent exercise. As a suggestion, try using pen and paper, the academic way, it’s an illuminating experience if you’re not yet used to it.</p>
<p>To understand better why this works out this way, consider the result of lifting <code>j</code>, multiple times in a row. I’ll explicitly include some syntactic peculiarities that functional programmers keep in their mind. So our basic setup is delineated in the following code block, where we go one level deep.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">j               ::</span> a <span class="ot">-&gt;</span> <span class="dt">Char</span>    <span class="co">-- b ~ Char</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="fu">fmap</span><span class="ot">            ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="fu">fmap</span><span class="ot"> j          ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f <span class="dt">Char</span></span></code></pre></div>
<p>Let’s descend another level deeper or lift another level higher. Note the remark on the syntactic precedence of function application, also denoted by the infix operator <code>($) :: (a -&gt; b) -&gt; a -&gt; b</code> with <code>infixr 0 $</code>, over the composition operator <code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code> with <code>infixl 9 .</code> which means that function application as in <code>fmap j</code> takes precedence over composition as in <code>fmap . fmap j</code>, which is in contrast to the desired composition <code>(fmap . fmap)</code> applied to <code>j</code>. I’ll specify the corresponding types explicitly, so as to immediate recognize that it’s a different object.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap     ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) </span>
<span id="cb12-2"><a href="#cb12-2"></a>                <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (g (f a) <span class="ot">-&gt;</span> g (f b))</span>
<span id="cb12-3"><a href="#cb12-3"></a>(<span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span>)<span class="ot"> j ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) </span>
<span id="cb12-4"><a href="#cb12-4"></a>                <span class="ot">=&gt;</span> g (f a) <span class="ot">-&gt;</span> g (f <span class="dt">Char</span>)</span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> j   <span class="co">-- Precedence of application: &#39;infixr 9 .&#39; vs &#39;infixr 0 $&#39;.</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>  <span class="op">==</span> <span class="fu">fmap</span> <span class="op">.</span> (<span class="fu">fmap</span> j)<span class="ot">   ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) </span>
<span id="cb12-7"><a href="#cb12-7"></a>                       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f <span class="dt">Char</span>)</span></code></pre></div>
<p>Good, next level.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span><span class="ot"> fmap     ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Functor</span> h)</span>
<span id="cb13-2"><a href="#cb13-2"></a>                       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (h (g (f a)) <span class="ot">-&gt;</span> h (g (f b)))</span>
<span id="cb13-3"><a href="#cb13-3"></a>(<span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span>)<span class="ot"> j ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Functor</span> h)</span>
<span id="cb13-4"><a href="#cb13-4"></a>                       <span class="ot">=&gt;</span> (h (g (f a)) <span class="ot">-&gt;</span> h (g (f b)))</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> j </span>
<span id="cb13-6"><a href="#cb13-6"></a>  <span class="op">==</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> (<span class="fu">fmap</span> j)<span class="ot"> ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g)</span>
<span id="cb13-7"><a href="#cb13-7"></a>                       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (g (f a) <span class="ot">-&gt;</span> g (f <span class="dt">Char</span>))</span></code></pre></div>
<p>And finally the fourth.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span><span class="fu">fmap</span><span class="ot">       ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Functor</span> h, <span class="dt">Functor</span> k)</span>
<span id="cb14-2"><a href="#cb14-2"></a>                       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (k (h (g (f a))) <span class="ot">-&gt;</span> k (h (g (f b))))</span>
<span id="cb14-3"><a href="#cb14-3"></a>(<span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> )<span class="ot"> j ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Functor</span> h, <span class="dt">Functor</span> k)</span>
<span id="cb14-4"><a href="#cb14-4"></a>                       <span class="ot">=&gt;</span> (k (h (g (f a))) <span class="ot">-&gt;</span> k (h (g (f b))))</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> j </span>
<span id="cb14-6"><a href="#cb14-6"></a>  <span class="op">==</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span> <span class="op">.</span> (<span class="fu">fmap</span> j)<span class="ot"> ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Functor</span> h)</span>
<span id="cb14-7"><a href="#cb14-7"></a>                       <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (h (g (f a)) <span class="ot">-&gt;</span> h (g (f <span class="dt">Char</span>)))</span></code></pre></div>
<p>This way we now can access nested levels of functorial superstructures such as <code>k (h (g (f a)))</code>, which could be more complex, such as <code>k (h (g a) (f b))</code>, where <code>h</code> is a <code>Bifunctor</code> instance<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>, any tree nesting basically, and with recursive, linear, or dependent types it goes much farther than this. We will leave these abstractions for later. This idea will come in handy when we deal with lifting monadic values in the context of monad transformers.</p>
<h1 data-number="3" id="implementations-for-maybe-and" data-number="3"><span class="header-section-number">3</span> Implementations for <code>Maybe</code> and <code>[]</code></h1>
<p>Let’s implement the <code>Functor</code> type class for the <code>Maybe</code> and the <code>[]</code> type constructors. For correctness, enable the <code>InstanceSigs</code> language extension in GHC, otherwise comment out the type signature inside.</p>
<h2 data-number="3.1" id="a-functor-instance-for-maybe" data-number="3.1"><span class="header-section-number">3.1</span> A <code>Functor</code> instance for <code>Maybe</code></h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span>  <span class="co">-- Recall: f ~ Maybe :: * -&gt; *</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<ol type="1">
<li>identity law:</li>
</ol>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="fu">fmap</span> <span class="fu">id</span> <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span>               <span class="op">==</span>  <span class="fu">id</span> <span class="dt">Nothing</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="fu">fmap</span> <span class="fu">id</span> (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (<span class="fu">id</span> x) <span class="ot">=</span> <span class="dt">Just</span> x  <span class="op">==</span>  <span class="fu">id</span> (<span class="dt">Just</span> x)</span></code></pre></div>
<ol start="2" type="1">
<li>composition law:</li>
</ol>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f <span class="op">$</span> <span class="dt">Nothing</span> <span class="ot">=</span> <span class="fu">fmap</span> g <span class="dt">Nothing</span>    <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="op">==</span>  <span class="fu">fmap</span> (g <span class="op">.</span> f) <span class="dt">Nothing</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f <span class="op">$</span> <span class="dt">Just</span> x  <span class="ot">=</span> <span class="fu">fmap</span> g (<span class="dt">Just</span> f x) <span class="ot">=</span> <span class="dt">Just</span> ((g <span class="op">.</span> f) x)</span>
<span id="cb17-4"><a href="#cb17-4"></a>  <span class="op">==</span>  <span class="fu">fmap</span> (g <span class="op">.</span> f) (<span class="dt">Just</span> x)</span></code></pre></div>
<p>This instance makes <code>Maybe</code> a functor: a <code>Maybe</code> value can now be mapped over with <code>fmap</code>, it now conforms to the essence of the functor. And here you can see how our instance preserves the <code>Maybe</code> structure:</p>
<ul>
<li>a <code>Nothing</code> becomes a <code>Nothing</code>, and</li>
<li>a <code>Just x</code> value, where <code>x :: a</code> and <code>a</code> is an arbitrary type, becomes a <code>Just (f x)</code> value.</li>
</ul>
<p>This consistency is crucial. Our mapped function needs not and cannot know anything about the particular <code>Functor</code> instance <code>f</code>. If this feels tedious, feel free to skip such proofs on first reading. But they are essential. Here’s why. Let’s write an incorrect instance which the compiler won’t raise a red flag on.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>  <span class="fu">fmap</span> _ (<span class="dt">Just</span> _) <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>which is equivalent to simply</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>  <span class="fu">fmap</span> _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>This instance already fails even the identity law. Indeed, in this case, <code>fmap id (Just 'x') = Nothing /= Just 'x' = id (Just 'x')</code>.</p>
<p>Alternatively, we can fix some arbitrary value.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Just</span> <span class="ch">&#39;x&#39;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>  <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>This instance also violates the identity law. Indeed, in this case, <code>fmap id Nothing = Just 'x' /= Nothing = id Nothing</code>.</p>
<p>But we could also define <code>Maybe</code> to be the <strong>identity functor</strong>, which regardless of the mapped function always gives back the input values.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>  <span class="fu">fmap</span> _ (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> x</span></code></pre></div>
<p>This instance now seems to preserve the structure. Indeed, it seems to satisfy both</p>
<ul>
<li>the identity law, for
<ul>
<li><code>fmap id Nothing = Nothing == id Nothing</code> and</li>
<li><code>fmap id (Just x) = Just x == id (Just x)</code>, for any <code>x</code>,</li>
</ul></li>
<li>and the composition law, for
<ul>
<li><code>fmap g . fmap f $ Nothing = fmap g Nothing = Nothing = fmap (g . f) Nothing</code>, and</li>
<li><code>fmap g . fmap f $ Just x = fmap g (Just x) = Just x = fmap (g . f) (Just x)</code>, for any composable <code>g</code> and <code>f</code> and every <code>x</code>.</li>
</ul></li>
</ul>
<p>But it doesn’t in fact type-check! Recall that <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. So what if <code>a ~ Int</code> and <code>b ~ Char</code>, so that the argument function <code>f :: Int -&gt; Char</code>? Then the first pattern on <code>Nothing</code> would type-check flawlessly, but the second on <code>Just x</code> would not if <code>x</code> is not both <code>Int</code> and <code>Char</code> at the same time. But <code>Int</code> and <code>Char</code> are distinct! This is a contradiction. All would be well if only we could assume that <code>b ~ a</code> so we could have taken <code>f = id</code>, but we cannot. In other words, we <em>must</em> incorporate the transformation <code>a -&gt; b</code> somehow in the instance definition. I can’t express in words how much I appreciate that GHC is so incredibly smart! <span class="redHeart">♥</span> It turns out, this was actually not the identity functor in the first place!</p>
<p>And now an example where everything type-checks and the identity law is satisfied but the law of composition is violated. Is it even possible? We need to try to fail the fourth identity above. Can we?</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>  <span class="fu">fmap</span> _ <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="fu">fmap</span> _ (<span class="dt">Just</span> _) <span class="ot">=</span> <span class="fu">undefined</span>  <span class="co">-- The bottom value, which inhabits every type.</span></span></code></pre></div>
<p>This type-checks flawlessly. But, is <code>undefined == undefined</code>? Let’s see what we need to assert.</p>
<ul>
<li><code>fmap id Nothing = Nothing    == id Nothing</code>, this is correct.</li>
<li><code>fmap id (Just x) = undefined == id undefined</code>, this is questionable.</li>
<li><code>fmap g . fmap f $ Nothing = fmap g Nothing = Nothing   == fmap (g . f) Nothing</code>, which is correct.</li>
<li><code>fmap g . fmap f $ Just x = fmap g undefined = undefined == fmap (g . f) (Just x)</code>, which also is questionable.</li>
</ul>
<p>Anyway, this is a pathological corner case, one which we must be aware of, nonetheless. As noted, <code>undefined</code> is the bottom value, which inhabits every type. In other words, this is the only value that can take on any type, exactly as we need here. Due to Haskell’s lazy evaluation strategy, it’s harmless as long it is not evaluated and sits as a placeholder essentially, that makes our programs type-check and compile, as long as we have not yet filled the space it occupies with good code. But <em>if it is evaluated</em>, the program exits with a runtime error. In fact, <code>undefined = error "Prelude.undefined"</code>. And <code>length [undefined, undefined] == 2</code> since no evaluation of the values inside the list takes place. When we type-check we force an evaluation up to the weak-head normal form (WHNF), which is the evaluation up to the outermost constructor.</p>
<p>As a side note, we cannot instantiate <code>Maybe</code> more than once, for a given type class. To overcome this limitation, <code>newtype</code>s are introduced that are transparent wrappers at compile time so as to facilitate type checking, and are discarded in the binary code. For each new type, such as <code>newtype Maybe' a = Maybe' {runMaybe' :: Maybe a}</code>, a new instance of the same class can be defined, e.g., <code>instance Functor Maybe' where</code>, which describes a different behavior — that nonetheless must be law-abiding!</p>
<h2 data-number="3.2" id="a-functor-instance-for-lists" data-number="3.2"><span class="header-section-number">3.2</span> A <code>Functor</code> instance for lists, <code>[]</code></h2>
<p>Our second concrete type of (linked) lists, <code>[]</code>, is a functor too (and also so much more!) and its instance is also relatively straightforward to specify. Recall I said earlier that the length of a list is its inherent property and that functorial mapping <code>fmap</code> is guaranteed to preserve the structure of a functorial value. Granted, lift extension or shrinkage is trivial, but it is not a functorial action! So our basic tenet for the instantiation of <code>[]</code> as a <code>Functor</code> will be maintenance of the structure. For comparison, first our <code>Maybe</code> instance.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span>  <span class="co">-- Recall: f ~ Maybe :: * -&gt; *</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="op">~</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> f b <span class="op">~</span> <span class="dt">Maybe</span> b</span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="fu">fmap</span> f <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>  <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>We ensured its correctness above by performing type-inference for the identity and the composition laws that are part of the definition of a functor, both in category theory and in Haskell. So if you are reading this and want to implement a functor in your language of choice, then make sure your instance also satisfies the laws, it is an overarching, language-independent inherent part of the notion.</p>
<p>Now, let’s look at our list instance.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> [] <span class="kw">where</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="op">~</span> [a] <span class="ot">-&gt;</span> f b <span class="op">~</span> [b]</span>
<span id="cb24-3"><a href="#cb24-3"></a>  <span class="fu">fmap</span> f []     <span class="ot">=</span> []</span>
<span id="cb24-4"><a href="#cb24-4"></a>  <span class="fu">fmap</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">fmap</span> f xs  <span class="co">-- Recursive!</span></span></code></pre></div>
<p>We now need to verify the functorial laws.</p>
<ol type="1">
<li><p>identity law: <code>fmap id [] = [] = id []</code> and <code>fmap id xs'@(x:xs) = x : fmap id xs = ... = xs = id xs'</code>, for any list <code>xs' :: [a]</code>.</p></li>
<li><p>composition law: for this we will invoke the method of proof by structural induction</p>
<ul>
<li>induction basis: <code>fmap (g . f) [] = [] = fmap g [] = fmap g (fmap f []) = (fmap g . fmap f) []</code></li>
<li>induction hypothesis: suppose <code>xs'@(x:xs)</code> are such that <code>fmap (g . f) xs = (fmap g . fmap f) xs</code>, and we need to show that, given this assumption, <code>fmap (g . f) xs' = (fmap g . fmap f) xs</code>:</li>
</ul>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="fu">fmap</span> (g <span class="op">.</span> f) xs&#39;<span class="op">@</span>(x<span class="op">:</span>xs) <span class="ot">=</span> (g <span class="op">.</span> f) x <span class="op">:</span> <span class="fu">fmap</span> (g <span class="op">.</span> f) xs </span>
<span id="cb25-2"><a href="#cb25-2"></a>                        <span class="ot">=</span> g (f x) <span class="op">:</span> (<span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f) xs</span></code></pre></div>
<p>where we used the hypothesis in the last equality. And, conversely,</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a>(<span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f) xs&#39; <span class="ot">=</span> <span class="fu">fmap</span> g (<span class="fu">fmap</span> f xs&#39;) <span class="ot">=</span> <span class="fu">fmap</span> g (f x <span class="op">:</span> <span class="fu">fmap</span> f xs) </span>
<span id="cb26-2"><a href="#cb26-2"></a>                                            <span class="ot">=</span> g (f x) <span class="op">:</span> <span class="fu">fmap</span> g (<span class="fu">fmap</span> f xs) </span>
<span id="cb26-3"><a href="#cb26-3"></a>                                            <span class="ot">=</span> g (f x) <span class="op">:</span> (<span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f) xs</span></code></pre></div></li>
</ol>
<p>That’s it. One important nit-pick: ellipses <code>...</code> in proofs are, well, kinda acceptable on this informal level of discourse as we are maintaining here, but if you wanted to do it formally correct, you would have to express them as a complete induction with induction basis and induction hypothesis. In future, this will be an exercise for you. So if you feel you didn’t get it from this particular example, just read up on it on Wikipedia, it’s wonderful.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> <span class="redHeart">♥</span></p>
<h1 data-number="4" id="other-standard-data-types" data-number="4"><span class="header-section-number">4</span> Other Standard Data Types</h1>
<h2 data-number="4.1" id="sum-and-product-types" data-number="4.1"><span class="header-section-number">4.1</span> Sum and Product Types</h2>
<p>Let’s look at the type constructor <code>Either</code> that generalizes <code>Maybe</code> and the type constructor tuple <code>(,)</code>. They are defined as</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">data</span> (,)    a b <span class="ot">=</span> (a,b)</span></code></pre></div>
<p>The most fundamental notion that they represent is that of sum types and product types, respectively. I mean, we can write equivalently</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">data</span> <span class="dt">Sum&#39;</span>    a b  <span class="ot">=</span> <span class="dt">One</span> a <span class="op">|</span> <span class="dt">Two</span> b</span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="kw">data</span> <span class="dt">Product&#39;</span> a b <span class="ot">=</span> <span class="dt">Product&#39;</span> a b</span></code></pre></div>
<p>A sum type represents alternatives and has multiple constructors, here <code>Left</code> and <code>Right</code> or <code>One</code> and <code>Two</code>; logically this corresponds to <code>OR</code>. A product type represents conjunction and has but one constructor, here <code>(,)</code> or <code>Product'</code>.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>A propositional logical system can be well-defined with just negation and either of conjunction or disjunction. Indeed, the implication <span class="math display">\[p \to q \equiv \neg (p \wedge \neg q) \equiv \neg p \vee q.\]</span></p>
<p>For predicate logics Haskell offers explicit and implicit <code>forall</code>s. Existential quantification can be given in terms of the universal quantification by means of negation. We will not go as far yet. But note that GHC offers rank-<span class="math inline">\(n\)</span> types and existential types.</p>
<p><span class="exercise"> <em>Exercise</em> Do you see in how what sense <code>Either</code> generalizes <code>Maybe</code> and <code>Maybe</code> specifies <code>Either</code>? Work this out. </span></p>
<p>By induction, sum and product types are well-defined for any finite natural number <span class="math inline">\(n\)</span>. This basic idea is crucial for dependent types, too.</p>
<p><span class="exercise"> <em>Exercise</em> If <span class="math inline">\(\sigma \in \Sigma\)</span> is a sum type, and <span class="math inline">\(\pi \in \Pi\)</span> a product type, where the capital letters represent sets of sum and product types, respectively, then what types belong to the sum set <span class="math display">\[\Sigma + \Pi := \left\{ \sigma + \pi \;\mid\; \sigma \in \Sigma,\; \pi \in \Pi \right\}\]</span> and the product sets <span class="math inline">\(\Pi\Sigma\)</span> and <span class="math display">\[\Sigma \Pi := \left\{ \sigma \pi \;\mid\; \sigma \in \Sigma,\; \pi \in \Pi \right\}\]</span> respectively, where we define <span class="math inline">\(\sigma + \pi = \sigma | \pi\)</span> and <span class="math inline">\(\sigma\pi = \sigma\, \pi\)</span> as above in terms of Haskell? </span></p>
<h3 data-number="4.1.1" id="functor-instance-for-either" data-number="4.1.1"><span class="header-section-number">4.1.1</span> Functor Instance for <code>Either</code></h3>
<p>Let’s define our instance. There is only one difference from <code>Maybe</code>, and this is the “arity” of <code>Either</code>, i.e., its kind is <code>* -&gt; * -&gt; *</code> whereas <code>Maybe :: * -&gt; *</code>, and a <code>Functor</code> can be any type constructor <code>f :: * -&gt; *</code>. So we need to make <code>Either</code> a binary type constructor. In Haskell, kinds are also curried, so we can simply bind the first type variable. In short: <code>Maybe</code> is a unary wheres <code>Either</code> is a binary type constructor.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Either</span> a) <span class="kw">where</span>  <span class="co">-- f :: * -&gt; * whereas Either :: * -&gt; * -&gt; *</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>  <span class="fu">fmap</span> _ (<span class="dt">Left</span> x)  <span class="ot">=</span> <span class="dt">Left</span> x</span>
<span id="cb29-3"><a href="#cb29-3"></a>  <span class="fu">fmap</span> f (<span class="dt">Right</span> x) <span class="ot">=</span> <span class="dt">Right</span> (f x)</span></code></pre></div>
<ol type="1">
<li>identity law: <code>fmap id (Left x) = Left x = id (Left x)</code> and <code>fmap if (Right x) = Right x = id (Right x)</code>.</li>
<li>composition law: <code>fmap (g . f) (Left x) = Left x = fmap g (fmap f (Left x)) = fmap g . fmap f $ Left x</code>.</li>
</ol>
<p><span class="exercise"> <em>Exercise</em> Make sure you can follow these lines. Write out on paper if you don’t understand every single step here. </span></p>
<p>Why did we choose to bind the first subtype and not the second? Well, in Haskell we don’t have kind-level <span class="math inline">\(\lambda\)</span>-expressions. Other than this I’m not aware of any technical or formal reason, so it seems to be a bit arbitrary. We can, if necessary, define another sum type like <code>Either' a b = Left' b | Right' b</code> in which we flip the order manually.</p>
<p><em>Remark</em>. Recall, by induction, this is valid for any finite natural number of subtypes in a sum type.</p>
<h3 data-number="4.1.2" id="functor-instance-for" data-number="4.1.2"><span class="header-section-number">4.1.2</span> Functor Instance for <code>(,)</code></h3>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> ((,) a) <span class="kw">where</span>  <span class="co">-- (,) :: * -&gt; * -&gt; *, and (,) a = (a,) :: * -&gt; *</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>  <span class="fu">fmap</span> g (x,y) <span class="ot">=</span> (x, g y)</span></code></pre></div>
<ol type="1">
<li>identity law: <code>fmap id (x,y) = (x, y) = id (x,y)</code></li>
<li>composition law: <code>fmap (g . f) (x,y) = (x, (g.f) y)</code> and <code>fmap g (fmap f (x,y)) = fmap g (x, f y) = fmap g (x, g (f y))</code>.</li>
</ol>
<p><span class="exercise"> <em>Exercise</em> I’ve shortened the notation a bit here. Check whether this was indeed admissible. </span></p>
<p>Again, why did we choose to bind the first subtype and not the second? Same reason: no kind-level <span class="math inline">\(\lambda\)</span>-expressions.</p>
<p><span class="exercise"> <em>Exercise</em> If you’re wondering why we didn’t take <code>(g x, g y)</code>, then look at the types.<br />
(<em>Hint</em>: the functorial type constructor here <code>f ~ (t,)</code>, for a fixed arbitrary type <code>t</code>, and <code>fmap :: (a -&gt; b) -&gt; f a ~ (t,a) -&gt; f b ~ (t,b)</code>. So <code>(g x, g y) :: (b, b)</code> instead of <code>f b ~ (a,b)</code> !) </span></p>
<p><em>Remark</em>. Recall, by induction, this is valid for any finite natural number of subtypes in a product type.</p>
<h2 data-number="4.2" id="function-type--" data-number="4.2"><span class="header-section-number">4.2</span> Function Type <code>(-&gt;)</code></h2>
<p>Now this is where it gets mind boggling. Spoiler: it turns out <code>fmap</code>ping over a function is just function composition! And it <em>has to be</em>! Wonder why? Let’s take a look! First, as always, our instance definition. Again, since the function type constructor is <code>(-&gt;) :: * -&gt; * -&gt; *</code>, we need to bind its first type argument.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>  <span class="co">-- f ~ (-&gt;) a = (a -&gt;) :: * -&gt; *</span></span>
<span id="cb31-2"><a href="#cb31-2"></a>  <span class="fu">fmap</span> g <span class="op">...</span></span></code></pre></div>
<p>… erm, now we’re stuck… How do we even refer to a function here? Let’s go backwards. Let’s first analyze the types and see how we can meet our requirements. Okay, so <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code> and <code>f ~ (t -&gt;)</code> here, for a fixed arbitrary type <code>t</code>. So <code>fmap :: (a -&gt; b) -&gt; (t -&gt; a) -&gt; (t -&gt; b)</code>. But that’s exactly the signature of function composition <code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code>. So in order to simply type-check, we can try using function composition. This is by no means an exhaustive, at most a heuristic, approach to finding the definition. But it works here just perfectly. When we deal below with the two functorial laws, we’ll see why this definition is sufficient and necessary! Let’s now finish our definition.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>  <span class="co">-- f ~ (-&gt;) a = (a -&gt;) :: * -&gt; *</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="co">--fmap = (.)         -- For brevity.</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>  <span class="fu">fmap</span> g f <span class="ot">=</span> g <span class="op">.</span> f   <span class="co">-- For clarity.</span></span></code></pre></div>
<p>Now, the functorial laws.</p>
<ol type="1">
<li><p>Identity law: <code>fmap id f = id . f = f</code> — now that was easy.</p></li>
<li><p>Composition law:<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> for this we will need to assert <strong>associativity of composition</strong><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>,</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a>(<span class="fu">fmap</span> h <span class="op">.</span> <span class="fu">fmap</span> g) f <span class="ot">=</span> <span class="fu">fmap</span> h (<span class="fu">fmap</span> g f) <span class="ot">=</span> <span class="fu">fmap</span> h (g <span class="op">.</span> f) <span class="ot">=</span> h <span class="op">.</span> (g <span class="op">.</span> f) </span>
<span id="cb34-2"><a href="#cb34-2"></a>  <span class="ot">=</span> h <span class="op">.</span> g <span class="op">.</span> f <span class="ot">=</span> (h <span class="op">.</span> g) <span class="op">.</span> f <span class="ot">=</span> <span class="fu">fmap</span> (h <span class="op">.</span> g) f</span></code></pre></div></li>
</ol>
<p><span class="exercise"> <em>Exercise</em> Make sure you understand this. Write this out otherwise. </span></p>
<p>Now, why is <code>(.)</code> the only right way here? What if we had other functions with the same signature? Now do we actually? Let’s see… a function <code>x :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code>, for arbitrary types <code>a</code>, <code>b</code>, and <code>c</code>… Let’s just use Hoogle! Well, there are a few, but they all are just the same composition! What if this is theoretically justified? Note that there are no constraints on the types <code>a</code>, <code>b</code> or <code>c</code>, which means that <code>x</code> must be able to deal with any type! What was special about <code>id :: a -&gt; a</code>? It knows nothing about <code>a</code>, so it can’t process <code>a</code> in any way, as there’s no way to know <em>just how</em> it <em>could</em> process <code>a</code> in the first place. This situation is in fact not unique. We will encounter it later in the context of <strong>existential types</strong>, which formalize separation of concerns by transferring specification of argument types from the callee to the caller.</p>
<p>And here, <code>x</code> must take two functions of arbitrary arguments, of which it only knows that they are coherent by ordering and repetition — the only actual bit of knowledge about them is that <code>b</code> is input to the first and output to the second argument. Now given this information alone (number of arguments, their types (function types), and the type <code>b</code>), we have to somehow fill in the gap here. On the other hand, we have the two functorial laws, but as you see they are trivial for function composition. So it’s really that consistency about <code>b</code>.</p>
<p><em>Exercise</em>: Work this out.</p>
<p>Just kidding! Look, we want to understand why only <code>(.)</code> fits that type signature. We have to make this type-check. Let’s just spell it out according to the type signature alone.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="ot">x ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb35-2"><a href="#cb35-2"></a>x g f a <span class="ot">=</span> <span class="kw">let</span> b <span class="ot">=</span> f a <span class="kw">in</span> g b</span></code></pre></div>
<p>Woah! But that’s just <code>g (f a)</code>, i.e., the function composition <code>(g . f) a</code>. So indeed <code>x = (.)</code>. This was a bit more tedious than it should be, but I hope it’s clear enough to be able to follow the lines of the argument, even if you’re not yet comfortable enough with this form of reasoning. In mathematics, the higher the degree of formal maturity, the shorter simple arguments become, but the more complex are the constructions. The complexity of expression shifts somewhat.</p>
<p><span class="exercise"> <em>Exercise</em> This is still a bit hand-wavy. Figure out how to fill the blanks. Not kidding this time. It isn’t hard. Just repeat the argument and see what may be missing. </span></p>
<h3 data-number="4.2.1" id="functor-instances-for-sum-and-product" data-number="4.2.1"><span class="header-section-number">4.2.1</span> Functor Instances for <code>Sum'</code> and <code>Product'</code></h3>
<p>There is no difference beyond notation between <code>Sum'</code> and <code>Either</code> on the one hand and <code>Product'</code> and <code>(,)</code> on the other. Suffices to write it out explicitly.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">data</span> <span class="dt">Sum&#39;</span> a b     <span class="ot">=</span> <span class="dt">One</span> a <span class="op">|</span> <span class="dt">Two</span> b</span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">data</span> <span class="dt">Product&#39;</span> a b <span class="ot">=</span> <span class="dt">Product</span> a b</span>
<span id="cb36-3"><a href="#cb36-3"></a></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Sum&#39;</span> a) <span class="kw">where</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>  <span class="fu">fmap</span> f (<span class="dt">One</span> a) <span class="ot">=</span> <span class="dt">One</span> a</span>
<span id="cb36-6"><a href="#cb36-6"></a>  <span class="fu">fmap</span> f (<span class="dt">Two</span> b) <span class="ot">=</span> <span class="dt">Two</span> (f b)</span>
<span id="cb36-7"><a href="#cb36-7"></a></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Product&#39;</span> a) <span class="kw">where</span></span>
<span id="cb36-9"><a href="#cb36-9"></a>  <span class="fu">fmap</span> f (<span class="dt">Product&#39;</span> a b) <span class="ot">=</span> <span class="dt">Product&#39;</span> a (f b)</span></code></pre></div>
<p>It is a bit different for phantom types</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">data</span> <span class="dt">Phantom</span> a p <span class="ot">=</span> <span class="dt">Phantom</span> a</span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Phantom</span> a) <span class="kw">where</span></span>
<span id="cb37-4"><a href="#cb37-4"></a>  <span class="fu">fmap</span> _ (<span class="dt">Phantom</span> a) <span class="ot">=</span> <span class="dt">Phantom</span> a</span></code></pre></div>
<p>or in other words <em>essentially</em> <code>fmap _ = id</code>.</p>
<p>But not for existential types:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">data</span> <span class="dt">Existential</span> a <span class="ot">=</span> <span class="kw">forall</span> e<span class="op">.</span> <span class="dt">Existential</span> a e</span>
<span id="cb38-2"><a href="#cb38-2"></a></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Existential</span> <span class="kw">where</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>  <span class="fu">fmap</span> f (<span class="dt">Existential</span> a e) <span class="ot">=</span> <span class="dt">Existential</span> (f a) e</span></code></pre></div>
<p><span class="exercise"> <em>Exercise</em> Verify the <code>Functor</code> laws for each of these four instances. </span></p>
<h2 data-number="4.3" id="reader-writer-and-state-monads" data-number="4.3"><span class="header-section-number">4.3</span> Reader, Writer, and State Monads</h2>
<p>You might be wondering what the point of the above academic “nonsense” was. Good question! Look, in Haskell and functional programming in general, we make use of such academic abstractions to ensure correctness of our code. This is not much different from the object-oriented design patterns most developers are used to. Here we have a strong theoretic background to ensure correctness. And we will use it where it makes sense and is reasonable.</p>
<p>The abstract take above paved the road, for example, for the Reader, Writer, and State monads. They all express how an effectful computation interacts with its environment. Computations in the context of Reader can only access read-only values stored in the environment, in the Writer monad, they can only write to the environment, and in the State context, a computation can both read from and write to its particular environment. This is separation of concerns at its foundations. From these building blocks we will go further and rise higher.</p>
<p>But first, let’s implement their <code>Functor</code> instances. For this we first need to know how Reader, Writer, and State are defined. As I said earlier, they are nothing but what we already know. So we can implement them just in terms of:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> r a   <span class="ot">=</span> <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }</span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="kw">newtype</span> <span class="dt">Writer</span> w a   <span class="ot">=</span> <span class="dt">Writer</span> {<span class="ot"> runWriter ::</span> (w, a) }</span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="kw">newtype</span> <span class="dt">State</span>  r w a <span class="ot">=</span> <span class="dt">State</span>  {<span class="ot"> runState  ::</span> r <span class="ot">-&gt;</span> (w, a) }</span></code></pre></div>
<p><em>Remark</em> (Transformers). In Haskell they are implemented in the Transformers library (transformers) and in the Monad Transformers library (mtl), where the latter builds atop the former.</p>
<p><em>Remark</em> (Records notation). Let’s dissect the definition of <code>Reader</code> here.</p>
<ol type="1">
<li><p><code>newtype Reader r a</code>:</p>
<ol type="i">
<li><code>newtype</code>: this is akin to <code>data</code>, albeit admits only a single value constructor, a transparent type wrapper, defines a syntactically (but not semantically) distinct type (in contrast to <code>type</code> synonyms, which are syntactically the same types).</li>
<li><code>Reader r a</code>: type constructor <code>Reader</code> takes two arbitrary types <code>r</code> and <code>a</code>, its kind is `* -&gt; * -&gt; *`.</li>
</ol></li>
<li><p><code>=</code> reads like “<em>… is defined as …</em>” or “<em>… can be constructed as …</em>”.</p></li>
<li><p><code>Reader { runReader :: r -&gt; a }</code>: this describes how a value of type <code>Reader r a</code> can be constructed: just provide a function <code>r -&gt; a</code>, for any type <code>r</code> and any type <code>a</code>.</p>
<ol type="i">
<li><code>Reader</code>: this is the name of the value constructor which we can use for pattern matching, where the action of pattern matching would have the type signature <code>Reader r a -&gt; (r -&gt; a)</code>, whereas the type signature of the value constructor is <code>Reader :: (r -&gt; a) -&gt; Reader r a</code>. Don’t get confused by the same name; this is commonplace in Haskell; the type constructor <code>Reader</code> and the value constructor <code>Reader</code> live on different levels of syntax.</li>
<li><code>{ runReader :: r -&gt; a }</code>: this is a “record”, which essentially is just the same as <code>Reader (r -&gt; a)</code> with an implicit accessor <code>runReader :: Reader r a -&gt; (r -&gt; a)</code>.</li>
</ol>
<p>So we have three actions here:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="dt">Reader</span><span class="ot">       ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a <span class="co">-- Value constructor.</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="ot">runReader    ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="co">-- Accessor, or deconstructor.</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="ot">patternMatch ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="co">-- Pattern matching action (destructuring).</span></span></code></pre></div>
<p>The “destructuring” is not like in C++ or Java, though. Alright. But since we defined <code>Reader</code>, <code>Writer</code>, and <code>State</code> in terms of what we already have <code>Functor</code> instances for, do we need to define (and verify) the respective instances for these three type constructors? Well, we do. But only because we used <code>newtype</code> expressions. Had we used <code>type</code> expressions, we wouldn’t need to, albeit we wouldn’t be able to use the record syntax, not that we need it: <code>type Reader' r a = r -&gt; a</code> and then <code>runReader' :: Reader' r a -&gt; (r -&gt; a); runReader' = id</code>, but this would be pretty much useless. As I said earlier, <code>newtype</code>s are there so we can implement different (but correct) instances for the same type; they are nothing but transparent wrappers about a type (sum, product, or any other type that is admissible); syntactically they appear as distinct types, even though under the hood they are the same, and once the program is compiled, there is no distinction anymore, at runtime they are the same. So let’s implement those instances. But we don’t have to reinvent the wheel! We can simply refer to the <code>run...</code> accessors now! Look:</p></li>
</ol>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> r) <span class="kw">where</span>  <span class="co">-- f ~ Reader r ~ (r -&gt;) :: * -&gt; *</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a        <span class="ot">-&gt;</span> f b</span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="co">--fmap :: (a -&gt; b) -&gt; Reader r a -&gt; Reader r b</span></span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="co">--fmap :: (a -&gt; b) -&gt; (r -&gt; a)   -&gt; (r -&gt; b)</span></span>
<span id="cb41-5"><a href="#cb41-5"></a>  <span class="fu">fmap</span> g x <span class="ot">=</span> <span class="dt">Reader</span>       <span class="co">-- ^ Reader        :: (r -&gt; b)-&gt; Reader r b             -- Repack.</span></span>
<span id="cb41-6"><a href="#cb41-6"></a>           <span class="op">$</span> <span class="fu">fmap</span> g       <span class="co">-- ^ fmap g = (g.) :: f a ~ (r -&gt; a) -&gt; f b ~ (r -&gt; b)  -- Delegate.</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>           <span class="op">$</span> runReader x  <span class="co">-- ^ runReader     :: Reader r a -&gt; (r -&gt; a)            -- Unwrap.</span></span></code></pre></div>
<p>The laws are certainly satisfied.</p>
<p><span class="exercise"> <em>Exercise</em> Check that blatant assertion. </span></p>
<p>As you see, we don’t even need to think much about how to connect the dots here because we simply can delegate this task to <code>fmap</code> we have for the function embedded in <code>Reader</code>, simply because it already is functorial. This is true of all <code>newtype</code> declarations, whenever we just want a fancy synonym. But as I said, this is not the actual purpose of <code>newtype</code>s, just a convenient side-effect.</p>
<p>On we go to Writer.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>  <span class="fu">fmap</span> g x <span class="ot">=</span> <span class="dt">Writer</span>          <span class="co">-- Writer              :: (w, b) -&gt; Writer w b  -- Repack.</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>           <span class="op">$</span> <span class="fu">fmap</span> g          <span class="co">-- fmap g a = (w, g a) :: (w, a) -&gt; (w, b)      -- Delegate.</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>           <span class="op">$</span> runReader x     <span class="co">-- runReadr            :: Writer w a -&gt; (w, a)  -- Unwrap.</span></span></code></pre></div>
<p><span class="exercise"> <em>Exercise</em> Verify the <code>Functor</code> laws. </span></p>
<p>And finally the State.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">State</span> r w) <span class="kw">where</span>  <span class="co">-- State r w :: * -&gt; *</span></span>
<span id="cb43-2"><a href="#cb43-2"></a>  <span class="fu">fmap</span> g x <span class="ot">=</span> <span class="dt">State</span>            <span class="co">-- State         :: (r -&gt; (w, b)) -&gt; State r w b</span></span>
<span id="cb43-3"><a href="#cb43-3"></a>           <span class="op">$</span> (<span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span>) g  <span class="co">-- fmap . fmap g :: g (f a) -&gt; g (f b)</span></span>
<span id="cb43-4"><a href="#cb43-4"></a>           <span class="op">$</span> runState x       <span class="co">-- :: State r w a -&gt; (r -&gt; (w, a)) ~ Reader r (Writer w a)</span></span></code></pre></div>
<p><span class="exercise"> <em>Exercise</em> Verify the <code>Functor</code> laws. </span></p>
<p>Note how we used <code>fmap . fmap</code> to delegate twice, level by level, where <code>g ~ (r-&gt;) ~ Reader r</code> and <code>f ~ (w,) ~ Writer w</code>. Can you recognize how our earlier tedious abstraction <code>fmap . fmap</code> takes the burden and saves our precious time here? We had to do that only once, and can reuse this abstraction everywhere, as we are doing here! This is due to the remark concerning type equality in the fourth line above.</p>
<p><span class="exercise"> <em>Exercise</em> Work this out in more detail. Specifically, write out what <code>(fmap . fmap) g</code> does here (<em>Hint</em>: simply write out the definitions explicitly) and see how everything type-checks. </span></p>
<p><span class="exercise"> <em>Exercise</em> Express <code>State</code> in terms of <code>Reader</code> and <code>Writer</code> as above. What are the semantics of <code>Writer w (Reader r a)</code>? Let <code>State' r w a = State' { runState' :: Reader r (Writer w a) }</code>, and then write and verify <code>Functor</code> instances for both. </span></p>
<p>If you’re wondering why the header calls these derivative types “monads,” this is just how they are most commonly referred to, if you want to look them up elsewhere, because they are instances of the <code>Monad</code> type class. I’m going to explain this in more detail a next article. We will encounter these standard type constructors often enough. Come back to this post anytime you feel you forgot how we defined them.</p>
<p>And that’s it. Let’s wrap up. With all the wrapping and unwrapping we’ve done above, it sounds almost like a pun.</p>
<h1 data-number="5" id="key-take-aways" data-number="5"><span class="header-section-number">5</span> Key Take-Aways</h1>
<p>Haskell the language as such is essentially about management of guarantees and advanced quality assurance, ensuring consistency and correctness of our code. It doesn’t come free: the initial mental burden is arguably significant. But once you pass a certain threshold, get used to thinking just enough formally to make sense of it, you’re good to go, and GHC will become a great virtual partner in this sort of pair programming.</p>
<p>Let’s conclude this post with a quick bullet-point summary.</p>
<ul>
<li>A <code>Functor</code> is a type class for type constructors <code>f :: * -&gt; *</code> that exhibit the behavior of preservation of structure of the value on every <code>fmap</code> application.</li>
<li>We can compose functors with functors, i.e., nest them inside like a ladder. This becomes handy when we have embedded structures and want to <code>fmap</code> across all of them to reach the leaf that stores the value we actually want to transform — all while being guaranteed to preserve the functorial structure!</li>
<li>Important standard functors are the canonical sum type constructors <code>Maybe</code> and <code>Either</code>, the list type constructor <code>[]</code>, the function type constructor <code>(r-&gt;)</code> for any <code>r</code>, the canonical product type constructor <code>(w,)</code> for any <code>w</code>, and their derivatives <code>Reader r</code>, <code>Writer w</code>, and <code>State r w</code>.</li>
<li>It is important to not only define an instance of a type class but also verify that the particular instance satisfies its laws. When we later deal with black-box (property-based) testing in Haskell, we’ll see how to automate this a bit, which is especially convenient for hard cases. This way you can untangle your CI/CD pipeline and simplify the entire lifecycle, including refactoring. One of the major factors is that type signatures provide an excellent expression of intent.</li>
</ul>
<h1 data-number="6" id="bonus-material" data-number="6"><span class="header-section-number">6</span> Bonus Material</h1>
<p>The following two sections are a bit advanced and serve only as appetizers for related concepts to discover and improve your Haskell and functional skills.</p>
<h2 data-number="6.1" id="somewhat-esoteric-functor-instances" data-number="6.1"><span class="header-section-number">6.1</span> Somewhat Esoteric Functor Instances</h2>
<h3 data-number="6.1.1" id="identity" data-number="6.1.1"><span class="header-section-number">6.1.1</span> <code>Identity</code></h3>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">data</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> a</span>
<span id="cb44-2"><a href="#cb44-2"></a></span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb44-4"><a href="#cb44-4"></a>  <span class="fu">fmap</span> _ <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p><span class="exercise"> <em>Exercise</em> Work out the <code>Functor</code> laws. </span></p>
<p>The point of <code>Identity</code> is to fill the gaps and to validate other pieces of code. It is an important cornercase on the type level akin to the function <code>id</code> on the term level.</p>
<h3 data-number="6.1.2" id="const" data-number="6.1.2"><span class="header-section-number">6.1.2</span> <code>Const</code></h3>
<p>Another peculiar parametric type is <code>Const</code>, which similar to the function <code>const :: a -&gt; b -&gt; a</code> that ignores its second argument and is commonly used in the form <code>y = const x :: b -&gt; a</code> where <code>x :: a</code>, to specify a <strong>constant</strong> (morphism), which for any argument gives the same output <code>x</code>. It’s dual to <code>id</code> in a way.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">data</span> <span class="dt">Const</span> a b <span class="ot">=</span> <span class="dt">Const</span> a</span>
<span id="cb45-2"><a href="#cb45-2"></a></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Const</span> a) <span class="kw">where</span></span>
<span id="cb45-4"><a href="#cb45-4"></a>  <span class="fu">fmap</span> _ (<span class="dt">Const</span> a _) <span class="ot">=</span> <span class="dt">Const</span> a</span></code></pre></div>
<p><span class="exercise"> <em>Exercise</em> Work out the <code>Functor</code> laws. </span></p>
<p>The essential peculiarity from the point of view of type theory is the opaque or <strong>phantom type</strong> variable <code>b</code> present in the type constructor <code>Const</code> on the left-hand side but absent from the value constructor <code>Const</code> on the right-hand side. For each distinct type <code>b</code>, the resulting type <code>Const a b</code> is distinct, for every type <code>a</code>. In other words, we can encode additional information in the particular type <code>Cosnt a T</code>, where <code>T</code> is a concrete type that the type variable <code>b</code> assumes, without making it accessible to the construction–desctructuring by pattern matching.</p>
<p>The dual notion is that of <strong>existential types</strong>, which are given as</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a><span class="kw">data</span> <span class="dt">Existential</span> a <span class="ot">=</span> <span class="kw">forall</span> b<span class="op">.</span> <span class="dt">Existential</span> a b</span></code></pre></div>
<p>and where, dually, the type constructor <code>Existential</code> doesn’t know anything about that type <code>b</code> its witnesses (values) are constructed with by using the value (or witness) constructor <code>Existential</code>, which by the way must be oblivious to that <code>b</code>, as by this explicit <code>forall</code> declaration we transfer the choice of the particular type <code>b</code> to the caller; in other words value construction must work independently of the concrete type <code>b</code>, i.e., for all types <code>b</code>.</p>
<h3 data-number="6.1.3" id="io" data-number="6.1.3"><span class="header-section-number">6.1.3</span> <code>IO</code></h3>
<p>Among Haskell’s types, the <code>IO</code> type constructor is the most peculiar, especially in its implementation via the <code>RealWorld</code> construct. More on this in another post. The most important thing to take away here is that <code>IO</code> is a <code>Functor</code>, which enable us to use <code>fmap</code> on its values. Such an <code>IO</code> value <code>x :: IO a</code>, for a given type <code>a</code>, describes a computation of type <code>a</code> that involves input or output, albeit need not be executed. It is a formulation of the computation, not the computation as such. When an <code>IO a</code> value is evaluated, its execution takes place.</p>
<p>For instance, <code>putStrLn :: String -&gt; IO ()</code> and <code>getLine :: IO String</code>. So let <code>x = getLine</code>, so we can apply <code>fmap ("Hi, " ++) :: Functor f =&gt; f String -&gt; f String</code> to <code>x</code> and get another <code>IO String</code> value. We will dive deeper into <code>IO</code> when we deal with monads, as it’s the natural playground for <code>IO</code> in Haskell. Stay tuned!</p>
<h2 data-number="6.2" id="natural-transformations" data-number="6.2"><span class="header-section-number">6.2</span> Natural Transformations</h2>
<p>I said in the introduction above that functors can be considered as</p>
<ol type="1">
<li>morphisms between categories with categories as objects, in the category <span class="math inline">\(\mathbf{Cat}\)</span> of cateogories, or</li>
<li>objects with natural transformations between them as morphisms, in the category of functors.</li>
</ol>
<p>So far we’ve only covered the first perspective. Now it’s time for the second one.</p>
<p>Let <span class="math inline">\(F : C \to D\)</span> and <span class="math inline">\(G : C \to D\)</span> denote a functors between a pair of categories <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span>. A <strong>natural transformation</strong> <span class="math inline">\(\eta : F \to G\)</span> between these functors is a family of morphisms, indexed by the objects of <span class="math inline">\(C\)</span>, such that</p>
<ol type="1">
<li><span class="math inline">\(\eta\)</span> (consistently) associates the morphism <span class="math inline">\(\eta_a : Fa \to Ga\)</span> in <span class="math inline">\(D\)</span>, for every object <span class="math inline">\(a\)</span> in <span class="math inline">\(C\)</span>,</li>
<li>coherent commutativity: <span class="math inline">\(\eta_b \circ Ff = Gf \circ \eta_a\)</span>, for every morphism <span class="math inline">\(f : a \to b\)</span> in <span class="math inline">\(C\)</span>.</li>
</ol>
<p>It captures the essence of mutating the structure <code>f -&gt; g</code> while preserving the content of the type <code>a</code>.</p>
<p>So while we have the morphism <code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code> in the category of categories, we want a morphism <code>nat :: (f -&gt; g) -&gt; (f a -&gt; g a)</code> in the category of functors, where <code>f</code> and <code>g</code> are both <code>Functor</code> instances. Apparently, we have to level up. In GHC this model is implemented as the (now obsolete) <code>Rank2Types</code> language extension, a particular case (and now just a synonym) for higher-kinded types handled by the <code>RankNTypes</code> language extension. Both imply <code>ExplicitForall</code>.</p>
<h3 data-number="6.2.1" id="rankntypes" data-number="6.2.1"><span class="header-section-number">6.2.1</span> <code>RankNTypes</code></h3>
<p>Let’s specify two concrete types <code>S</code> and <code>T</code> for brevity. You can replace them with <code>forall a. a</code> everywhere. Let’s then check what the rank of the function types is.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">data</span> <span class="dt">S</span> <span class="ot">=</span> <span class="dt">S</span>; <span class="kw">data</span> <span class="dt">T</span> <span class="ot">=</span> <span class="dt">T</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="ot">r1 ::</span>                              <span class="kw">forall</span> b c<span class="op">.</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">T</span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="ot">r2 ::</span>  (<span class="kw">forall</span> d<span class="op">.</span> d <span class="ot">-&gt;</span> d)       <span class="ot">-&gt;</span> <span class="kw">forall</span> b c<span class="op">.</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">T</span></span>
<span id="cb47-4"><a href="#cb47-4"></a><span class="ot">r3 ::</span> ((<span class="kw">forall</span> d<span class="op">.</span> d <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> <span class="dt">S</span>) <span class="ot">-&gt;</span> <span class="kw">forall</span> b c<span class="op">.</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> <span class="dt">T</span></span>
<span id="cb47-5"><a href="#cb47-5"></a><span class="ot">u  ::</span> <span class="dt">S</span> <span class="ot">-&gt;</span> <span class="kw">forall</span> d<span class="op">.</span>          d <span class="ot">-&gt;</span> <span class="dt">T</span></span>
<span id="cb47-6"><a href="#cb47-6"></a><span class="ot">v  ::</span> <span class="dt">S</span> <span class="ot">-&gt;</span> <span class="kw">forall</span> d<span class="op">.</span> <span class="dt">Num</span> d <span class="ot">=&gt;</span> d <span class="ot">-&gt;</span> <span class="dt">T</span></span></code></pre></div>
<p>By convention, the scope of binding of the universal quantifier <span class="math inline">\(\forall\)</span> extends to the right until the end of the subexpression. This is the case with <code>forall</code> too. Variables not bound are called <strong>free</strong>. So in</p>
<ul>
<li><code>forall a b. a -&gt; b</code>, <code>a</code> and <code>b</code> are bound by that <code>forall</code>;</li>
<li><code>forall a. (forall b. b -&gt; a) -&gt; b</code>, the latter <code>a</code> was bound on the outside of the parentheses, whereas the latter <code>b</code> is free because the scope opf of the innermost <code>forall</code> expression is limited by the subexpression in the parentheses, and thereby invalidates the entire expression;</li>
<li><code>forall a (forall b. b -&gt; c) -&gt; a</code>, the inner <code>c</code> is free but the latter <code>a</code> is bound.</li>
</ul>
<p>By Skolemization, we can normalize the expression in line 4 to the equivalent expression in line 3, in other words, we can prefix all <code>forall a b c</code> in fron of all the arrows instead of quantifying each type variable individually in a chain of arrows; in other words we can move <code>forall b</code> to the left of <code>a -&gt; b</code> but we cannot move <code>forall a</code> to the right of <code>a -&gt; b</code> since <code>forall</code> binds to the right only.</p>
<p>The <strong>rank</strong> of a type is the level of nesting of such universally quantified subexpressions, plus one for the outermost level. Therefore:</p>
<ol type="1">
<li>The function <code>r1</code> is of a rank-one type; in its type signature only the implicit universal quantification of <code>b</code> and <code>c</code> was made explicit, nothing fancy yet.</li>
<li>It is different with <code>r2</code> where we prefix a function argument in front of it, which can only be <code>id</code>, as you may recall, which isn’t essential here, as the argument can also be of type <code>forall d. d -&gt; S</code>, say. This is indeed a rank-two type because a rank one argument to the right, which is precisely <code>r1</code>’s type, follows another rank-one type argument.</li>
<li>With <code>r3</code> it is similar: it is a rank-three (function) type, because it has a rank-two type preceding the outermost rank-one type function arrow <code>forall b c. b -&gt; c -&gt; T</code>.</li>
<li>The functions <code>u</code> and <code>v</code> have a rank-one type but are not valid Haskell98, and are handled by the <code>RankNTypes</code> extension, and their type signatures are reduced to the equivalent <code>u :: S -&gt;d -&gt; T</code> and <code>v :: Num d =&gt; S -&gt; d -&gt; T</code>.</li>
</ol>
<p>Now let’s replace <code>T</code> with something more complicated, e.g., the types below.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">newtype</span> <span class="dt">Rank1Type</span> a b    <span class="ot">=</span> <span class="dt">Rank1Type</span> (a <span class="ot">-&gt;</span> b)                    <span class="co">-- Our ordinary rank-one types.</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="kw">newtype</span> <span class="dt">ExistType</span> a      <span class="ot">=</span> <span class="kw">forall</span> b<span class="op">.</span> <span class="dt">ExistType</span> (a <span class="ot">-&gt;</span> b)          <span class="co">-- Rank-one existential type.</span></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="kw">newtype</span> <span class="dt">Rank2Type</span> a      <span class="ot">=</span> <span class="dt">Rank2Type</span> (<span class="kw">forall</span> b<span class="op">.</span> a <span class="ot">-&gt;</span> b)          <span class="co">-- Rank-two type.</span></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="kw">newtype</span> <span class="dt">Rank2Type&#39;</span>  a    <span class="ot">=</span> <span class="dt">Rank2Type&#39;</span> (a <span class="ot">-&gt;</span> <span class="kw">forall</span> b<span class="op">.</span> b)         <span class="co">-- Syntactically equivalent.</span></span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="kw">newtype</span> <span class="dt">Rank2TypeEx</span> a    <span class="ot">=</span> <span class="kw">forall</span> c<span class="op">.</span> <span class="dt">Rank2TypeEx</span>  (<span class="kw">forall</span> b<span class="op">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="co">-- Existential rank-2 type.</span></span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="kw">newtype</span> <span class="dt">Rank2TypeExP</span> a p <span class="ot">=</span> <span class="kw">forall</span> c<span class="op">.</span> <span class="dt">Rank2TypeExP</span> (<span class="kw">forall</span> b<span class="op">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="co">-- Phantom existential rank-2 type.</span></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="kw">newtype</span> <span class="dt">Rank3Type</span> a      <span class="ot">=</span> <span class="dt">Rank3Type</span> (<span class="kw">forall</span> b c<span class="op">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)   <span class="co">-- Rank-three type.</span></span>
<span id="cb48-8"><a href="#cb48-8"></a><span class="kw">newtype</span> <span class="dt">Rank4Type</span> a      <span class="ot">=</span> <span class="dt">Rank4Type</span> (<span class="kw">forall</span> b c d<span class="op">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="co">-- Rank-four type.</span></span></code></pre></div>
<p>Here, the value constructors are higher-rank functions, as they map <code>Rank2Type :: forall a. (forall b. a -&gt; b) -&gt; Rank2Type a</code>. But they construct a <code>Rank2Type</code> value from a rank-one function!</p>
<p><span class="exercise"> <em>Exercise</em> Count the arrows to make sure the names correctly reflect the semantics. What exactly is here rank-two? The value constructor or the resulting type? </span></p>
<p>For ordinary types, such as <code>Rank1Type</code> in the first line, the universal quantification of <code>a</code> and <code>b</code> is implicit on the left-hand side in the type constructor. The step to existential quantification is completed when we universally quantify a type in the constructor that does not belong to the type.</p>
<p>And a change to a phantomization in line 6, where type <code>p</code> is the corresponding phantom type, is completed by adding an extra type to the type constructor that does not belong to the respective value constructors.</p>
<h3 data-number="6.2.2" id="natural-transformation-as-an-existential-type" data-number="6.2.2"><span class="header-section-number">6.2.2</span> Natural Transformation as an Existential Type?</h3>
<p>So we said that a natural transformation is a family of morhisms. Look, if we write</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">data</span> <span class="dt">Eta</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Eta</span> a</span></code></pre></div>
<p>we’ll get a family of value constructors <code>Eta</code>, indexed by objects, which are the types <code>a</code> here. So, for every type <code>a</code>, <code>Eta a :: Eta</code>. What is it? We’re obviously missing the functors. So let</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">data</span> <span class="dt">Eta</span> f g <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Eta</span> {<span class="ot"> runEta ::</span> f a <span class="ot">-&gt;</span> g a }</span></code></pre></div>
<p>whose value constructor has the type <code>forall f g a. (f a -&gt; f a) -&gt; Eta f g</code> which, however, is <em>not equivalent</em> to <code>forall f g. (forall a. f a -&gt; g a) -&gt; Eta f g</code>, which is a rank-two type.</p>
<p>We wanted <code>Eta</code> to be oblivious to <code>a</code> so it cannot touch it in the first place.</p>
<h3 data-number="6.2.3" id="natural-transformation-as-a-higher-rank-function" data-number="6.2.3"><span class="header-section-number">6.2.3</span> Natural Transformation as a Higher-Rank Function</h3>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">newtype</span> <span class="dt">Eta</span> f g <span class="ot">=</span> <span class="dt">Eta</span> {<span class="ot"> runEta ::</span> <span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a }</span></code></pre></div>
<p>Here, <code>f</code> and <code>g</code> both must have the kind <code>* -&gt; *</code> as follows from their use in the constructor, where <code>a</code> is a rigid type variable, of kind <code>*</code>. Here, the type of the value constructor <code>Eta :: (forall a. f a -&gt; g a) -&gt; Eta f g</code> is of rank two. The accessor (or deconstructor) <code>runEta :: forall f g. Eta f g -&gt; forall a. f a -&gt; g a</code> has rank one because by Skolemization we arrive at the equivalent expression <code>runEta :: forall f g a. Eta f g -&gt; f a -&gt; g a</code>, without any nested <code>forall</code> subexpressions, as also prior to Skolemization.</p>
<p>Now we can map any type constructor <code>f</code> to any to constructor <code>g</code>, expressed by <code>Nat f g</code>. But that’s not what we originally wanted. The image <span class="math inline">\(\eta F\)</span> of a functor <span class="math inline">\(F\)</span> under a natural transformation <span class="math inline">\(\eta\)</span> must be the functor <span class="math inline">\(G\)</span>, as otherwise the desired mapping would not be well-defined, and also satisfy both the defining properties of a naturl transformation.</p>
<p>So let’s first impose the <code>Functor</code> constraint on <code>f</code> since we know that the argument to our natural transformation must be a functor, and then implement <code>Eta f</code> as a <code>Functor</code>. But note first the <code>Eta :: (* -&gt; *) -&gt; (* -&gt; *) -&gt; *</code>, but <code>Functor :: (* -&gt; *) -&gt; Constraint</code>, i.e., expects a type constructor <code>* -&gt; *</code> but not <code>(* -&gt; *) -&gt; *</code>. So simple type binding, i.e., <code>Eta f :: (* -&gt; *) -&gt; *</code>, won’t work here! How can we tackle this?</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Eta</span> f) <span class="kw">where</span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="ot">  fmap ::</span> (g <span class="ot">-&gt;</span> h) <span class="ot">-&gt;</span> (<span class="dt">Eta</span> f g) <span class="ot">-&gt;</span> (<span class="dt">Eta</span> f h)</span>
<span id="cb52-3"><a href="#cb52-3"></a>  <span class="fu">fmap</span> k x <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>I hope this gives at least a rough picture of what I said initially and what is possible to model and verify with Haskell. There is so much more to it! But first of all we must ensure we have a working understanding of the fundamental notions of functional software architecture and are capable to recognize its benefits and deficiencies. Haskell the platform is not perfect but it is excellent, with a wonderful patient and selfless community!<span class="redHeart">♥</span></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The tilde character <code>~</code> denotes “type equality.”<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>There are many ways to express verbally what <code>f</code> is. We use “<strong>functorial type <em>constructor</em></strong>” for “<strong>instance of the type class <code>Functor</code></strong>” (short: “<strong>Functor instance</strong>”), which it is since <code>f :: * -&gt; *</code>; one can also say that <code>f</code> is a <code>Functor</code> or a “functor,” which would arguably be a bit less precise. This disambiguation is not really important if your audience understands what exactly you are referring to. You can also refer to it as a <strong>parametrically polymorphic</strong> type <code>f</code>. A <strong>functorial value</strong> is any value <code>x</code> of type <code>f a</code>, where <code>f a</code> is a functorial type.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>In a category <span class="math inline">\(C\)</span>, a <strong>free object</strong> is the image of a <strong>free functor</strong> <span class="math inline">\(F : \mathbf{Set} \to C\)</span>, which assigns any set <span class="math inline">\(a\)</span> the object <span class="math inline">\(Fa\)</span> in <span class="math inline">\(C\)</span> that represents the minimal structure on the set that it must carry to be qualified to be an object in <span class="math inline">\(C\)</span>. For example, given a set <span class="math inline">\(a\)</span>, a free semigroup <span class="math inline">\(Fa\)</span> of <span class="math inline">\(a\)</span> is a semigroup structure superimposed on <span class="math inline">\(a\)</span>, which may require that some elements have to be discarded in order to satisfy the associativity of the semigroup operation as given by the functor <span class="math inline">\(F\)</span>, where also a choice between elements may have to be made. So this is not as trivial as it might seem on the surface.<br />
The <em>dual notion</em> is that of a <strong>forgetful functor</strong> <span class="math inline">\(U : C \to \mathbf{Set}\)</span>, which strips all structure of <span class="math inline">\(C\)</span> from an object <span class="math inline">\(a\)</span> to produce a set <span class="math inline">\(Ua\)</span>, e.g., if <span class="math inline">\(a\)</span> is a semigroup, then <span class="math inline">\(Ua\)</span> is its carrier with exactly the same elements but without the semigroup operation.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>A computation is said to be <strong>nondeterministic</strong> if given the same input, in produces different output, which doesn’t necessarily mean that it is a random variable, a deterministic list of values is enough because it leaves the choice of a single element open and so provides a branching decision tree. Admittedly, it’s a bit contrived. Moreover, the notion of nondeterminism in science is quite broad. In dynamical systems, nondeterminism can be modeled stochastically. Essentially nondeterminism means that multiple outcomes are possible.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>A <strong>bifunctor</strong> is essentially a bivariate functor, functorial in each argument. There are also contravariant functors and combinations with contravariance, which we need not be concerned with now.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p> This will become crucial for recursive data types, where the induction takes the form of <strong>structural induction</strong>, which we actually also are doing here. Moreover, in Haskell, lists are “infinite” types. The complete induction is only valid for any finite natural number, e.g., when you want to prove some assertion like “<em>for all <span class="math inline">\(n \in \mathbb{N}\)</span>, …</em>” but not directly for an assertion like “<em>the cardinality of this set is an infinite cardinal number…</em>”. For <span class="math inline">\(\mathbb{N}\)</span>, depending on the axioms you choose, say Peano’s, you can invoke <em>tertium non datur</em> and derive the result from a contradiction, whereas in intuitionistic formulations it’s a bit harder. However, this is not my field of expertise. So for infinities, you’ll need the <strong>transfinite induction</strong> over the ordinals (the complete induction goes only over the naturals, and structural induction goes by the construction).<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>I’m using apostrophe suffixes here to distinguish them from the corresponding <code>newtype</code>s in Prelude for <code>Monoid</code> instances.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>There is an important difference between a <strong>type constructor</strong> and a <strong>data (or value) constructor</strong>. In an expression like <code>data T a = C a</code>, <code>T</code> is a type constructor, <code>T a</code> is a type, whereas <code>C</code> is a data (or value) constructor, and <code>x :: T a</code> is a value of type <code>T a</code> that was constructed by the constructor <code>C</code>, which we can use in pattern matching when we write <code>x@(C y)</code> to extract the value <code>y :: a</code> from the <code>C</code> context. Recall that in Haskell, type variables are written lowercase, whereas concrete types are capital.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>Wait… <strong>composition of composition</strong>? Yes! This works too! Look (no obscenities intended) the <em>reflexivity</em> is a bit hard to grasp, just follow the types:<br />
</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="ot">(.)       ::</span>     (s <span class="ot">-&gt;</span> t)       <span class="ot">-&gt;</span>     ((a <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> t))</span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="ot">(.)       ::</span> s <span class="op">~</span> (b <span class="ot">-&gt;</span> c)       <span class="ot">-&gt;</span> t <span class="op">~</span> ((d <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (d <span class="ot">-&gt;</span> c))</span>
<span id="cb33-3"><a href="#cb33-3"></a>((<span class="op">.</span>) <span class="op">.</span>)<span class="ot">   ::</span> (a <span class="ot">-&gt;</span> s) <span class="op">~</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) </span>
<span id="cb33-4"><a href="#cb33-4"></a>          <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> t) <span class="op">~</span> a <span class="ot">-&gt;</span> (d <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (d <span class="ot">-&gt;</span> c)</span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="ot">(.)       ::</span> a&#39; <span class="op">~</span> (b <span class="ot">-&gt;</span> c)      <span class="ot">-&gt;</span> b&#39; <span class="op">~</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> c&#39; <span class="op">~</span> (a <span class="ot">-&gt;</span> c)</span>
<span id="cb33-6"><a href="#cb33-6"></a>(<span class="op">.</span>) <span class="op">.</span><span class="ot"> (.) ::</span> a&#39;        <span class="op">~</span> (b <span class="ot">-&gt;</span> c)</span>
<span id="cb33-7"><a href="#cb33-7"></a>          <span class="ot">-&gt;</span> (d <span class="ot">-&gt;</span> b&#39;) <span class="op">~</span> (d <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b)</span>
<span id="cb33-8"><a href="#cb33-8"></a>          <span class="ot">-&gt;</span> (d <span class="ot">-&gt;</span> c&#39;) <span class="op">~</span> (d <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c)</span></code></pre></div>
<p><span class="exercise"> <em>Exercise</em> Retrace each step. Soon we will see how such seemingly complex expressions turn out to be very useful in certain circumstances, especially library code can benefit from it. You certaintly don’t need to use them always. Most people don’t understand them. To write excellent Haskell, you don’t need this! </span><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>But associativity of function composition is <em>the</em> basic tenet of almost everything we do. Semigroups need this, and by extension categories.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></section>
</article>

<!-- <div id="disqus-thread"></div> -->
<!-- <script> -->
<!--   var disqus_config = function () { -->
<!--       this.page.identifier = '2020-03-31-haskell-functors'; -->
<!--   }; -->

<!--   (function () { -->
<!--       var d = document, s = d.createElement('script'); -->
<!--       s.src = 'https://demming.disqus.com/embed.js'; -->
<!--       s.setAttribute('data-timestamp', +new Date()); -->
<!--       (d.head || d.body).appendChild(s); -->
<!--   })(); -->
<!-- </script> -->
<!-- <noscript> -->
<!--     To view the --> 
<!--     <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a> -->
<!--     you need to enable JavaScript in your browser. -->
<!-- </noscript> -->
]]></summary>
</entry>
<entry>
    <title>Testing and Benchmarking Software in Haskell</title>
    <link href="https://demming.github.io/blog/2020/03/26/haskell-testing-benchmarking/index.html" />
    <id>https://demming.github.io/blog/2020/03/26/haskell-testing-benchmarking/index.html</id>
    <published>2020-03-26T00:00:00Z</published>
    <updated>2020-03-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="blog-post full">
  <header>
    <h1><a href="/blog/2020/03/26/haskell-testing-benchmarking/index.html">Testing and Benchmarking Software in Haskell</a></h1>
    <span class="subtitle">Learn to Use Testing and Benchmarking Libraries and Frameworks</span>
  </header>
  <section class="post-meta internal-links">
    
    <time class="post-date">March 26, 2020</time>
    <span class="post-tags"><ul><li><a href="/tags/HTF/index.html">HTF</a></li><li><a href="/tags/benchmark/index.html">benchmark</a></li><li><a href="/tags/criterion/index.html">criterion</a></li><li><a href="/tags/framework/index.html">framework</a></li><li><a href="/tags/haskell/index.html">haskell</a></li><li><a href="/tags/tasty/index.html">tasty</a></li><li><a href="/tags/test/index.html">test</a></li><li><a href="/tags/testing-framework/index.html">testing-framework</a></li><li><a href="/tags/verification/index.html">verification</a></li></ul></span>
  </section>
  <hr class="pre-content">
  <section class="post-content">
<div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#testing"><span class="toc-section-number">1</span> Testing</a>
<ul>
<li><a href="#black--white--and-gray-box-tests"><span class="toc-section-number">1.1</span> Black-, White-, and Gray-Box Tests</a></li>
<li><a href="#unit-tests"><span class="toc-section-number">1.2</span> Unit tests</a></li>
<li><a href="#integration-tests"><span class="toc-section-number">1.3</span> Integration tests</a></li>
<li><a href="#system-tests"><span class="toc-section-number">1.4</span> System tests</a></li>
<li><a href="#acceptance-tests"><span class="toc-section-number">1.5</span> Acceptance tests</a></li>
</ul></li>
<li><a href="#systems-design-and-architecture-requirements-and-tests-to-assure-behaviors-and-qualities"><span class="toc-section-number">2</span> Systems Design and Architecture, Requirements, and Tests to Assure Behaviors and Qualities</a>
<ul>
<li><a href="#views-and-viewpoints-on-the-system"><span class="toc-section-number">2.1</span> Views and Viewpoints on the System</a></li>
<li><a href="#requirements"><span class="toc-section-number">2.2</span> Requirements</a></li>
<li><a href="#testing-1"><span class="toc-section-number">2.3</span> Testing</a></li>
</ul></li>
<li><a href="#the-setting"><span class="toc-section-number">3</span> The Setting</a></li>
<li><a href="#testing-and-quality-assurance"><span class="toc-section-number">4</span> Testing and Quality Assurance</a>
<ul>
<li><a href="#fundamental-notions"><span class="toc-section-number">4.1</span> Fundamental Notions</a></li>
<li><a href="#typical-workflow"><span class="toc-section-number">4.2</span> Typical Workflow</a></li>
<li><a href="#examples"><span class="toc-section-number">4.3</span> Examples</a></li>
</ul></li>
</ul>
</div>
<h1 data-number="1" id="testing" data-number="1"><span class="header-section-number">1</span> Testing</h1>
<p>Software testing is aimed at discovery and assurance of properties of units, components, or the entire system. Testing can be organized in a pipeline fashion of CI/CD as a distinct stage, which constitutes a pipeline in its own right, in which testing stages are organized in sequence or in parallel so as to facilitate the development, integration, deployment, and delivery of software functionalities to the end user execution or run-time environment. Each test comprises at least one test case, which specifies the actions to be taken or inputs and outputs to be processed and matched. Tests should cover functional and qualitative properties of the program, including correctness of the implementation, absence of errors, performance bounds, etc.</p>
<p>Tests are run in a testing environment, which should ideally match the end-user’s deployment environment.</p>
<p>If it’s a pet project or a PoC for internal use, testing can be of secondary concern. But if your project is mission-critical, it must be tested. All financial, medical, physical, automotive, or aero-engineering applications, to name a few, must meet comprehensive quality and reliability requirements.</p>
<p>Haskell and GHC together provide strong type-level guarantees, which in fact is very much compared with other mainstream industry-grade production-ready languages. There have been attempts at increasing Haskell’s guarantees, e.g., with Liquid Haskell or Dependent Haskell, but it’s a different story. GHC like every compiler has its own bugs , so the guarantees are somewhat tainted. There are many facets to quality assurance in software engineering. We’re delving deeper into the type-theoretic guarantees in other articles on my blog, and here we’ll dive into the software testing part of it.</p>
<p>In this post we’re going to see how we can leverage Haskell’s type-system guarantees to even further improve the quality assurance for our software by harnessing Haskell testing facilities.</p>
<p>In fact, we can use Haskell’s testing facilities anytime with any non-Haskell project. Say, we develop a C++ program, we can employ  to test it. But we can also embed that C++ program in a Haskell testing environment and run the tests there, all we need to do is to map the types.</p>
<p>We’ll focus on <strong>dynamic testing</strong>, with test data generated automatically or provided by hand.</p>
<p>It is important to make clear that software testing is not a formal method of verification. It only enables a heuristic validation. The testing problem is combinatorial in nature (providing all feasible permutations of input and output pairs) and as a decision problem constitutes a superset of the halting problem, which is undecidable.</p>
<h2 data-number="1.1" id="black--white--and-gray-box-tests" data-number="1.1"><span class="header-section-number">1.1</span> Black-, White-, and Gray-Box Tests</h2>
<p>Some libraries provide white-box (structural) testing, while others are specialized in black-box (functional, property-based, invariant) testing.</p>
<p>There is also a variety of software testing approaches or models. More or less common is a hierarchy of “levels” of the tests. These are essentially four steps distinguished by the degree of abstraction or specificity.</p>
<h2 data-number="1.2" id="unit-tests" data-number="1.2"><span class="header-section-number">1.2</span> Unit tests</h2>
<p>At the lowest level of abstraction (and the highest level of specificity) in this hierarchy, the smallest coherent pieces of code, such as functions, are called “<strong>units</strong>.” This notion need not be as restrictive: any piece of code can be considered a unit essentially. <strong>Unit tests</strong> are written by the developer in a white-box fashion.</p>
<p>In unit testing, we want to isolate parts of our software and make sure that they individually work as intended. How they interact and whether they work well together is a different question which we are not concerned with at this level; it is answered at the integration level.</p>
<h2 data-number="1.3" id="integration-tests" data-number="1.3"><span class="header-section-number">1.3</span> Integration tests</h2>
<p>When writing software, we compose functions or objects. Our entire modern-day mathematics is a construction derived from a basic set of axioms in a particular logic. All system operations amount to mutation of CPU registers. Composition is everywhere, whether in sequence or concurrently in parallel.</p>
<p>An integration test is aimed to <em>heuristically</em> ensure compliance of a component’s API with another components’ APIs. Each component or module exposes a set of functions, variables, or classes to everyone else. Suppose our program composes components A and B. An integration test must ensure that both components’ interfaces are consistent. But, in contrast to a unit test, we do not look inside!</p>
<h2 data-number="1.4" id="system-tests" data-number="1.4"><span class="header-section-number">1.4</span> System tests</h2>
<p>On a higher level, when all our components are integrated and the integration tests are all passed, we can check whether the entire system works as expected on our particular test cases. The desired input and output pairs must be matched by the actual output of our system.</p>
<h2 data-number="1.5" id="acceptance-tests" data-number="1.5"><span class="header-section-number">1.5</span> Acceptance tests</h2>
<p><strong>User-acceptance (beta) test</strong> cases are best developed in collaboration with the end users or domain experts, in which real-world scenarios are played through for the program. This may include any regulatory and contractual constraints that the end-user must comply with.</p>
<p>The distinction between alpha and beta testing is usually simple: alpha testing is acceptance testing on the developers’ premises or environment, while beta testing is acceptance testing on the end-users’ premises or environment; with <strong>infrastructure as code</strong>, provisioning and accessing environments can be included in the developers’ test pipeline, in which case “beta” testing amounts to the involvement of domain experts on the buy side.</p>
<p>From cost efficiency perspective it should be apparent that the sequence of tests should follow this hierarchy, i.e., unit <code>-&gt;</code> integration <code>-&gt;</code> system <code>-&gt;</code> user acceptance. It is a good practice to devise a set of acceptance tests prior to beginning the project, in order to use them as the ultimate assurance and guiding line, from which the developers should not deviate. And then they can be refined in the process of continuous delivery.</p>
<p>Intertwined with each of these four stages, are functional and nonfunctional tests, and performance analysis.</p>
<h1 data-number="2" id="systems-design-and-architecture-requirements-and-tests-to-assure-behaviors-and-qualities" data-number="2"><span class="header-section-number">2</span> Systems Design and Architecture, Requirements, and Tests to Assure Behaviors and Qualities</h1>
<p>A system may exist ephemerally, but when we need to deal with it, different actors will have different perspectives on it, and different views (functional, informational, organizational, infrastructural) will represent the different concerns of the stakeholders.</p>
<p>In systems design, we specify the domain and the data models along with the architecture of our program. In fact, our program is just a method applied to the domain and acting upon the data. So our architecture specifies how the constituent pieces compose the entire system by interaction.</p>
<p>By means of devising a <strong>systems architecture</strong>, we provide a schematic view for the <strong>design</strong> of the system that describes the <strong>domain models</strong>. One part of the process is the <strong>functional modeling</strong> of our desired system, where a typical software development process that goes bottom-down begins with an eventual functional relationship and tries to decompose it in ever small constituent functions that (preferably exactly) compose to the original top-level function. The flip side is <strong>architectural modeling</strong> of the system. TODO</p>
<p>Functional requirements specify the desired behavior of a function in terms of a functional relationship between stated inputs and outputs. Recall that in mathematics, a relation <span class="math inline">\(R \subseteq A \times B\)</span> is called a <strong>function</strong> if it is left-total and right-unique (aka “functional”), where <strong>left totality</strong> means that for each element <span class="math inline">\(a\)</span> in the input set <span class="math inline">\(A\)</span> there exists an element <span class="math inline">\(b\)</span> in the output set <span class="math inline">\(B\)</span> such that <span class="math inline">\(aRb\)</span>, and <strong>right uniqueness</strong> means that we can map any element of <span class="math inline">\(A\)</span> to only (i.e., at most) one element of <span class="math inline">\(B\)</span>, or formally, for every choice of elements <span class="math inline">\(a \in A\)</span> and <span class="math inline">\(b,c \in B\)</span>, if <span class="math inline">\(aRb\)</span> and <span class="math inline">\(aRc\)</span>, then <span class="math inline">\(b=c\)</span> (in words: for any pair of elements in <span class="math inline">\(B\)</span>, if they are related to the same element in <span class="math inline">\(A\)</span>, then they must coincide, i.e., “we can map any <span class="math inline">\(a \in A\)</span> to only one <span class="math inline">\(b \in B\)</span>”).</p>
<p>There are many approaches at a concrete realization of these notions. But generally speaking, a <strong>domain model</strong> includes the model of the business processes and functions, whereas the <strong>system model</strong> includes the program logic and the requirements.</p>
<h2 data-number="2.1" id="views-and-viewpoints-on-the-system" data-number="2.1"><span class="header-section-number">2.1</span> Views and Viewpoints on the System</h2>
<p>If we partition our system by concerns of stakeholders, we will arrive at what is known as <strong>viewpoints</strong>, amounting to <strong>separation of concerns</strong>, and they determine the <strong>views</strong>, i.e., an interface to (or the representation of) the system that is limited to the viewpoint — those aspects are rendered that are of interest to the particular class of stakeholders. This includes the various structural and architectural,functional, behavioral and procedural perspectives on the system.</p>
<h2 data-number="2.2" id="requirements" data-number="2.2"><span class="header-section-number">2.2</span> Requirements</h2>
<p>A <strong>requirement</strong> is the prescription of a condition, capability, or state of the system that must be met or achieved. For our purposes we only need to distinguish between the functional and nonfunctional requirements, which are often conflated with other types of requirements.</p>
<p><strong>Functional requirements</strong> prescribe individual behaviors, procedures, effects and activities the system must exhibit, as given by a set of input and output pairs. The implementation of functional requirements is laid out in the corresponding <em>system design</em> intertwined with the app architecture. Behavioral business use cases go hand in hand with functional requirements.</p>
<p><strong>Nonfunctional requirements</strong> prescribe structural, operational, or architectural aspects or characteristics that the system must possess and adhere to, i.e., property constraints; they specify the states, qualities, properties, constraints, and anything technical that is unrelated to behavioral aspects of the system, e.g., costs, reliability, reproducibility, etc., but also performance. The implementation of nonfunctional requirements is laid out in the corresponding (technical and organizational) <em>system architecture</em>.</p>
<p>Nonfunctional requirements can be categorized in</p>
<ul>
<li>qualities of the execution process (run-time): availability, reliability, stability, usability, performance (like latency and throughput), security, correctness (adherence to the algorithms and the spec, numerical stability of the implementation, robustness), maintainability, testability, usability (UX)</li>
<li>evolutionary qualities: interaction with the ambient environment, maintainability, portability, flexibility (standards compliance), scalability, satisfaction of constraint (cloud cost limits, runtime limits, but also deadlines).</li>
<li>nontechnical aspects such as (legal) compliance with laws (privacy) and licensing, or meeting the budget constraints on a cloud service.</li>
</ul>
<p>All these aspects are noted individually, but in reality they all belong together. They become distinguished when we consider different <em>viewpoints</em>, as described above.</p>
<p>I prefer to consider <strong>performance requirements</strong> separately, which are validated by benchmarking. For example, in high-frequency trading<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> we always strive for low-latency and high-throughput systems, with important pieces embedded in tiny-memory network interface cards, whereas in not-so-high-frequency automated trading we focus more on system correctness and may want to invest more in formal verification. Contrast this with discretionary trading, where the UX tends to outweigh all other concerns — in this situation an average end-user will usually values the comfort of the GUI over top-grade performance, whereas in the HFT domain the GUI is only of value to analysts and managers, who make discretionary decisions, and the performance concern lies at the heart of the HFT business model.</p>
<h2 data-number="2.3" id="testing-1" data-number="2.3"><span class="header-section-number">2.3</span> Testing</h2>
<p>Testing is hard, testing is expensive. There is a hierarchy of testing approaches based on the detail and the depth of the tests. By first testing shallow cases that cover the most fundamental functionality or properties of the unit, integration, or the system, which still need be, we can save the cost from passing on faulty code that would falsify or at least taint any further test results. In the CI/CD, testing can be seen as a “sub-pipeline” essentially.</p>
<h3 data-number="2.3.1" id="functional-tests" data-number="2.3.1"><span class="header-section-number">2.3.1</span> Functional Tests</h3>
<p><strong>Functional testing</strong> heuristics are aimed at ensuring behavioral properties of the system. They may refer to any level in the hierarchy: unit, integration, system, or acceptance testing.</p>
<h4 data-number="2.3.1.1" id="shallow-testing-build-smoke-and-sanity-tests" data-number="2.3.1.1"><span class="header-section-number">2.3.1.1</span> Shallow testing: build, smoke, and sanity tests</h4>
<ul>
<li><p><strong>Build and smoke tests</strong>: must cover the most basic functionality of the unit or the system, aimed at ensuring that further more detailed testing down the CI pipeline is feasible, as often different teams run different tests or perhaps different functionality is tested in different environments.</p></li>
<li><p><strong>Sanity tests</strong>: also a shallow test, which amounts to weeding out corner cases, obviously false input-ouput pairs.</p></li>
</ul>
<h4 data-number="2.3.1.2" id="regression-tests" data-number="2.3.1.2"><span class="header-section-number">2.3.1.2</span> Regression Tests</h4>
<p>Every update or a bug fix may result in unintended consequences that break a feature that used to work correctly prior to the change (feature regression), or may affect the performance detrimentally (performance regression). It has only etymologically the same roots as regression models in statistics (the name stems from “regression to the mean” in the analysis of the average height of men in a study). The regression can be localized to a single unit, a module, or it can affect the product at the integration level. Another typical case is when the regression is due to a running a previous incorrect execution path. Recall that for a program to be correct, each of its execution paths must be correct.</p>
<p>To mitigate such issues, regression tests are deployed.</p>
<h4 data-number="2.3.1.3" id="usability-testing" data-number="2.3.1.3"><span class="header-section-number">2.3.1.3</span> Usability testing</h4>
<h3 data-number="2.3.2" id="nonfunctional-tests" data-number="2.3.2"><span class="header-section-number">2.3.2</span> Nonfunctional Tests</h3>
<p><strong>Nonfunctional testing</strong> heuristics are aimed at ensuring overall qualities of the system. Similarly, they may appear at each level of the hierarchy.</p>
<ul>
<li>docs testing</li>
<li>load and stress testing</li>
<li>performance testing</li>
<li>security testing</li>
<li>usability testing: qualities pertaining to the product.</li>
</ul>
<p>Much can be said about each of these types of tests, and about many more which will remain beyond the scope of this blog post.</p>
<h1 data-number="3" id="the-setting" data-number="3"><span class="header-section-number">3</span> The Setting</h1>
<p>Haskell is renowned for its <a href="https://hackage.haskell.org/packages/#cat:Testing">testing facilities</a>.</p>
<p>There is an ambiguity in the usage of the term “framework,” related to different contexts and scopes of the notion. For our purposes, we will call libraries such as HUnit and QuickCheck, but also Hspec, that provide an idiosyncratic formalism for the expression of tests, a “<strong>testing library</strong>,” whereas test-framewok, HTF, and tasty, but also Hspec, that introduce a unifying interface to more than one testing library, a “<strong>testing framework</strong>.” Apparently, Hspec belongs to both categories, for it comprises other testing libraries and at the same time provides own formalism for expressing tests.</p>
<p>Some major popular testing libraries (also call themselves “frameworks”, in which case the next group can be termed “meta-frameworks”):</p>
<ul>
<li>Doctest: an adaptation of Python’s <a href="TODO">doctest</a> package.</li>
<li>Hspec (cf. RSpec); a test format in its own right, but also a framework unifying HUnit, QuickCheck, SmallCheck)</li>
<li>HUnit: modeled after JUnit</li>
<li>QuickCheck: property-based black-box testing</li>
<li>SmallCheck: a simplification of QuickCheck</li>
<li>Hedgehog:</li>
</ul>
<p>Some major testing frameworks that provide a unifying layer or interface atop of the testing libraries:</p>
<ul>
<li>Hspec:
<ul>
<li>hspec-hedgehog</li>
<li>hspec-laws:</li>
<li>hspec-smallcheck</li>
<li>hspec-leancheck</li>
<li>hspec-slow</li>
<li>hspec-test-framework (and hspec-test-framework-th)</li>
<li>hspec-multicheck</li>
<li>hspec-wai and -wai-json</li>
<li>hspec-megaparsec, -parsec, -attoparsec</li>
</ul></li>
<li>test-framework: comprises HUnit tests and QuickCheck properties in a single interface.
<ul>
<li>relatively actively maintained, as of writing this.</li>
<li>test-generator (aka test-framework-th) was last updated in 2012.</li>
</ul></li>
<li>HTF (Haskell Testing Framework): automatically collects individual unit tests (hspec-discover only finds modules)
<ul>
<li>unit tests (HUnit)</li>
<li>QuickCheck properties</li>
<li>black-box tests</li>
<li>custom preprocessor gathering test definitions automatically; failure with exact file name and line number.</li>
</ul></li>
<li>tasty
<ul>
<li>tasty-laws</li>
<li>tasty-lens</li>
<li>tasty-th</li>
<li>tasty-tmux</li>
<li>tasty-wai</li>
<li>tasty-travis</li>
<li>tasty-stats</li>
<li>tasty-hunit</li>
<li>tasty-hspec</li>
<li>tasty-hedgehog and -hedgehog-coverage</li>
</ul></li>
</ul>
<p>Essentially, Hspec and Tasty are the two major frameworks we will be concerned with here.</p>
<p>Benchmarking:</p>
<ul>
<li>Criterion</li>
</ul>
<p>We first will investigate unit testing with HUnit and property testing with QuickCheck. After this, we will cover the frameworks that comprise both approaches.</p>
<h1 data-number="4" id="testing-and-quality-assurance" data-number="4"><span class="header-section-number">4</span> Testing and Quality Assurance</h1>
<h2 data-number="4.1" id="fundamental-notions" data-number="4.1"><span class="header-section-number">4.1</span> Fundamental Notions</h2>
<ul>
<li>Unit test (HUnit, tasty-hunit): see above.</li>
<li>Golden test (tasty-golden): unit tests whose results are stored in files, and a test is passed if that output file matches a reference file.</li>
<li>Property test (QuickCheck, SmallCheck, Hedgehog, LeanCheck): specify a property a function must adhere to, and test whether this is the case, in a black-box fashion.</li>
</ul>
<p>A framework is aimed at gathering these individual groups of tests in a single uniform test expression that the compiler will evaluate for us, to inform us whether everything’s fine. It is crucial especially when introducing changes to pristine code. Anything could go wrong. Recall that Haskell’s advanced type system makes most bugs travel back in time and emerge at compile-time rather than the runtime. This will save our users users from making unintended experience with our software. We want to make them happy and solve their problems, make their lives easier. Any runtime bug is an encumbrance on a user. It’s critical to reduce runtime bugs. So from the project budgeting perspective, if sufficient funds are available for testing, it’s very reasonable to give a very high priority to testing the runtime experience.</p>
<h2 data-number="4.2" id="typical-workflow" data-number="4.2"><span class="header-section-number">4.2</span> Typical Workflow</h2>
<p>So we have a two-step approach to ensuring this high quality of our products and services:</p>
<ol type="1">
<li>use Haskell to impose a high level of mandatory consistency, soundness, and correctness of our programs — nothing will compile that doesn’t meet that requirement (this imposes syntactic and logical correctness as expressed by types); and then additionally</li>
<li>test our programs thoroughly to ensure that we translated our ideas correctly into code — the compiler, GHC, will alert us whenever we specify that we want something different than what actually gets computed as a result (this imposes semantic and translational correctness as expressed by our test specifications).</li>
</ol>
<p>The Haskell ecosystem provides top-notch world-class quality assurance and testing facilities. It comes closest to formal verification, without the excessive burden and cost. It is a pragmatic gold standard of great quality of software. And should we indeed need to formally verify critical pieces of code, we’ve set the stage for it already. With Template Haskell, we can even attain automated test generation, including all the boilerplate potentially necessary. Moreover, we can use Haskell’s testing frameworks for other languages and platforms. We can also embed other languages in Haskell code and use it as our glue.</p>
<h2 data-number="4.3" id="examples" data-number="4.3"><span class="header-section-number">4.3</span> Examples</h2>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Since Michael Lewis’ book “Flashboys” at latest, the term “high-frequency trading” founds its way into mainstream vocabulary, albeit in a very slanted meaning, affected by a host of logical fallacies, most prominent of which is the hasty generalization from the misconduct of a few actors to the entire industry, and at the same time promoting the then-incepted IEX (“Inverstors’ Exchange”). This smells like too much marketing for a new competitor. But that’s long been a regular practice. Still, even an average buy-side retail trader should learn about HFT but from other sources. If interested, ask me for a couple suggestions.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></section>
</article>

<!-- <div id="disqus-thread"></div> -->
<!-- <script> -->
<!--   var disqus_config = function () { -->
<!--       this.page.identifier = '2020-03-26-haskell-testing-benchmarking'; -->
<!--   }; -->

<!--   (function () { -->
<!--       var d = document, s = d.createElement('script'); -->
<!--       s.src = 'https://demming.disqus.com/embed.js'; -->
<!--       s.setAttribute('data-timestamp', +new Date()); -->
<!--       (d.head || d.body).appendChild(s); -->
<!--   })(); -->
<!-- </script> -->
<!-- <noscript> -->
<!--     To view the --> 
<!--     <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a> -->
<!--     you need to enable JavaScript in your browser. -->
<!-- </noscript> -->
]]></summary>
</entry>
<entry>
    <title>Database Transactions and Management in Haskell</title>
    <link href="https://demming.github.io/blog/2020/03/26/haskell-persistent-sql-database/index.html" />
    <id>https://demming.github.io/blog/2020/03/26/haskell-persistent-sql-database/index.html</id>
    <published>2020-03-26T00:00:00Z</published>
    <updated>2020-03-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="blog-post full">
  <header>
    <h1><a href="/blog/2020/03/26/haskell-persistent-sql-database/index.html">Database Transactions and Management in Haskell</a></h1>
    <span class="subtitle">Persistent: Serialization, Datastore, ORM</span>
  </header>
  <section class="post-meta internal-links">
    
    <time class="post-date">March 26, 2020</time>
    <span class="post-tags"><ul><li><a href="/tags/data/index.html">data</a></li><li><a href="/tags/database/index.html">database</a></li><li><a href="/tags/haskell/index.html">haskell</a></li><li><a href="/tags/infrastructure/index.html">infrastructure</a></li><li><a href="/tags/serialization/index.html">serialization</a></li><li><a href="/tags/sql/index.html">sql</a></li></ul></span>
  </section>
  <hr class="pre-content">
  <section class="post-content">
<div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#limitations-in-persistent-that-can-be-overcome-with-esqueleto"><span class="toc-section-number">2</span> Limitations in Persistent that can be overcome with Esqueleto</a></li>
<li><a href="#fundamental-definitions"><span class="toc-section-number">3</span> Fundamental Definitions</a></li>
<li><a href="#entity-syntax"><span class="toc-section-number">4</span> Entity Syntax</a></li>
</ul>
</div>
<h1 data-number="1" id="introduction" data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>In Haskell, we have many database libraries. <a href="http://www.stackage.org/package/persistent">Persistent</a> is a layer atop, using some of them as its backends, that imposes type safety and seamless integration with Haskell code. With <a href="TODO"><code>persistent-odbc</code></a> many more DBMSs can be attached. Own drivers can be written. Whenever Persistent turns out to be insufficient, we can fall back to the raw driver or its Haskell wrapper, and write a Persistent ORM ourselves. The framework is wonderful, but as everything has its caveats. We will discuss some them in the course of this series of posts here.</p>
<p>In other words, Persistent is a seamless marshalling or serialization library that removes most boilerplate code<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>This marshalling or object-relational mapping (ORM) imposes type-safety onto the conventional untyped database drivers, which may be written in an arcane dialect of C (macros!), such as the <a href="TODO"><code>pgsql</code> driver</a>, notorious for its undocumented features. We thereby can employ Haskell’s type system and GHC’s facilities to ensure that we don’t make mistakes in our queries and that the data remains consistent throughout our data transformations. The key point here is that any errors that might occur are pulled back from runtime to compile-time, where we can fix it proactively. In particular, type-safety prevents SQL injection attacks.</p>
<p>There are basically four different approaches to dealing with databases in Haskell:</p>
<ol type="1">
<li><p>use the existing drivers provided as backends and create a layer atop that imposes Haskell types on the level of Haskell code — this is the approach of serialization, marshalling, or ORM taken by Persistent and <a href="https://hackage.haskell.org/package/esqueleto">Esqueleto</a> (more later), and many others listed below;</p></li>
<li><p>use the existing drivers via foreign-function interfaces (FFIs) by introducing a thin wrapper around them, and run direct textual queries, hoping for consistency — this is what <a href="https://hackage.haskell.org/package/sqlite-simple"><code>sqlite-simple</code></a> and <a href="https://hackage.haskell.org/package/postgresql-simple"><code>postgresql-simple</code></a> among others do (“mid-level client libraries”);</p></li>
<li><p>run third-party database drivers as subprocesses — this is very crude but may turn out to be necessary in some situations;</p></li>
<li><p>rewrite the existing driver directly in Haskell, which enables us to introduce category-theoretic abstractions that can simplify code and improve performance — this is what <a href="https://github.com/nikita-volkov">Nikita Volkov</a>’s <a href="https://github.com/nikita-volkov/hasql"><code>hasql</code></a> library for Postgres does.</p></li>
</ol>
<p>Some other persistence and ORM-like libraries:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/opaleye">Opaleye</a></li>
<li><a href="https://hackage.haskell.org/package/beam">Beam</a></li>
<li><a href="https://hackage.haskell.org/package/groundhog">Groundhog</a></li>
<li><a href="https://hackage.haskell.org/package/selda">Selda</a></li>
<li><a href="https://hackage.haskell.org/package/squeal-postgresql">Squeal</a></li>
<li><a href="https://github.com/jcristovao/migrationplus">Triggers for SQL</a></li>
<li><a href="https://github.com/gbwey/persistent-odbc">Persistent-ODBC</a></li>
<li><a href="https://hackage.haskell.org/package/persistent-zookeeper">Persistent-Zookeeper</a></li>
<li><a href="https://hackage.haskell.org/package/vault"><code>vault</code></a> (a persistent storage of values of arbitrary types)</li>
<li><a href="https://https://hackage.haskell.org/package/TCache"><code>TCache</code></a></li>
</ul>
<h1 data-number="2" id="limitations-in-persistent-that-can-be-overcome-with-esqueleto" data-number="2"><span class="header-section-number">2</span> Limitations in Persistent that can be overcome with Esqueleto</h1>
<p>So when do we use which of these two libraries?</p>
<ul>
<li>Persistent provides type-safe serialization of data. It allows for type-safe filtered storage and retrieval of data from a database (remote-resource, local resource, file, or in-memory databases). It does not support type-safe <code>JOIN</code>s, but we can fall back to explicit-string queries.</li>
<li>Esqueleto: provides an embedded domain-specific language (EDSL) for SQL and superposes type-safe <code>JOIN</code>s atop of Persistent SQL backends. As of writing this, Esqueleto supports only type-safe <code>SELECT</code>, <code>UPDATE</code>, <code>INSERT</code>, and <code>DELETE</code> queries. It does not provide for all SQL features. So we can either implement them by hand whenever necessary, which is relatively easy, or switch to the fall-back mode of explicit-string queries.</li>
</ul>
<p>We can use both libraries in the same module, in which case we would have to import at least one of them qualified, so as to avoid identifier conflicts.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- For a module that mostly uses esqueleto.</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span> <span class="dt">Database.Esqueleto</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Database.Persistent</span> <span class="kw">as</span> <span class="dt">P</span></span></code></pre></div>
<p>or import <code>esqueleto</code> itself qualified:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- For a module that uses esqueleto just on some queries.</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">import</span> <span class="dt">Database.Persistent</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Database.Esqueleto</span> <span class="kw">as</span> <span class="dt">E</span></span></code></pre></div>
<p>Our plan is to first learn to use Persistent, and then extend it with Esqueleto.</p>
<h1 data-number="3" id="fundamental-definitions" data-number="3"><span class="header-section-number">3</span> Fundamental Definitions</h1>
<p>Here is the fundamental correspondence<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>:</p>
<table>
<thead>
<tr class="header">
<th>SQL DBMS</th>
<th>Persistent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Data types</td>
<td><code>PersistValue</code></td>
</tr>
<tr class="even">
<td>Column</td>
<td><code>PersistField</code></td>
</tr>
<tr class="odd">
<td>Table</td>
<td><code>PersistEntity</code></td>
</tr>
</tbody>
</table>
<p>Also consider this migrations (conversions) table for marshalling<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>:</p>
<table>
<thead>
<tr class="header">
<th>Haskell</th>
<th>PostgreSQL</th>
<th>MySQL</th>
<th>MongoDB</th>
<th>SQLite</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Text</code> |</td>
<td><code>VARCHAR</code></td>
<td><code>TEXT</code></td>
<td><code>String</code></td>
<td><code>VARCHAR</code></td>
</tr>
<tr class="even">
<td><code>ByteString</code></td>
<td><code>BYTEA</code></td>
<td><code>BLOB</code></td>
<td><code>BinData</code></td>
<td><code>BLOB</code></td>
</tr>
<tr class="odd">
<td><code>Int</code></td>
<td><code>INT8</code></td>
<td><code>BIGINT(20)</code></td>
<td><code>NumberLong</code></td>
<td><code>INTEGER</code></td>
</tr>
<tr class="even">
<td><code>Double</code></td>
<td><code>DOUBLE PRECISION</code></td>
<td><code>DOUBLE</code></td>
<td><code>Double</code></td>
<td><code>REAL</code></td>
</tr>
<tr class="odd">
<td><code>Rational</code></td>
<td><code>NUMERIC(22,12)</code></td>
<td><code>DECIMAL(32,20)</code></td>
<td><em>unsupported</em></td>
<td><code>NUMERIC(32,20)</code></td>
</tr>
<tr class="even">
<td><code>Bool</code></td>
<td><code>BOOLEAN</code></td>
<td><code>TINYINT(1)</code></td>
<td><code>Boolean</code></td>
<td><code>BOOLEAN</code></td>
</tr>
<tr class="odd">
<td><code>Day</code></td>
<td><code>DATE</code></td>
<td><code>DATE</code></td>
<td><code>NumberLong</code></td>
<td><code>DATE</code></td>
</tr>
<tr class="even">
<td><code>TimeOfDay</code></td>
<td><code>TIME</code></td>
<td><code>TIME</code><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></td>
<td><em>unsupported</em></td>
<td><code>TIME</code></td>
</tr>
<tr class="odd">
<td><code>UTCTime</code><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></td>
<td><code>TIMESTAMP</code></td>
<td><code>DATETIME</code><a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></td>
<td><code>Date</code></td>
<td><code>TIMESTAMP</code></td>
</tr>
</tbody>
</table>
<p>And, in particular, for MySQL and MariaDB:</p>
<table>
<colgroup>
<col style="width: 42%" />
<col style="width: 57%" />
</colgroup>
<thead>
<tr class="header">
<th>Haskell type</th>
<th>Compatible MySQL types</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Bool</code></td>
<td><code>Tiny</code></td>
</tr>
<tr class="even">
<td><code>Int8</code></td>
<td><code>Tiny</code></td>
</tr>
<tr class="odd">
<td><code>Int16</code></td>
<td><code>Tiny</code>, <code>Short</code></td>
</tr>
<tr class="even">
<td><code>Int32</code></td>
<td><code>Tiny</code>, <code>Short</code>, <code>Int24</code>, <code>Long</code></td>
</tr>
<tr class="odd">
<td><code>Int</code></td>
<td><code>Tiny</code>, <code>Short</code>, <code>Int24</code>, <code>Long</code>, <code>LongLong</code><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></td>
</tr>
<tr class="even">
<td><code>Int64</code></td>
<td><code>Tiny</code>, <code>Short</code>, <code>Int24</code>, <code>Long</code>, <code>LongLong</code></td>
</tr>
<tr class="odd">
<td><code>Integer</code></td>
<td><code>Tiny</code>, <code>Short</code>, <code>Int24</code>, <code>Long</code>, <code>LongLong</code></td>
</tr>
<tr class="even">
<td><code>Word8</code></td>
<td><code>Tiny</code></td>
</tr>
<tr class="odd">
<td><code>Word16</code></td>
<td><code>Tiny</code>, <code>Short</code></td>
</tr>
<tr class="even">
<td><code>Word32</code></td>
<td><code>Tiny</code>, <code>Short</code>, <code>Int24</code>, <code>Long</code></td>
</tr>
<tr class="odd">
<td><code>Word64</code></td>
<td><code>Tiny</code>, <code>Short</code>, <code>Int24</code>, <code>Long</code>, <code>LongLong</code></td>
</tr>
<tr class="even">
<td><code>Double</code></td>
<td><code>Float</code>, <code>Double</code>, <code>Decimal</code>, <code>NewDecimal</code>, <code>Tiny</code>, <code>Short</code>, <code>Int24</code>, <code>Long</code></td>
</tr>
<tr class="odd">
<td><code>Ratio Integer</code></td>
<td><code>Float</code>, <code>Double</code>, <code>Decimal</code>, <code>NewDecimal</code>, <code>Tiny</code>, <code>Short</code>, <code>Int24</code>, <code>Long</code>, <code>LongLong</code></td>
</tr>
<tr class="even">
<td><code>ByteString</code></td>
<td><code>VarChar</code>, <code>TinyBlob</code>, <code>MediumBlob</code>, <code>LongBlob</code>, <code>Blob</code>, <code>VarString</code>, <code>String</code>, <code>Set</code>, <code>Enum</code></td>
</tr>
<tr class="odd">
<td><code>Lazy.ByteString</code></td>
<td><code>VarChar</code>, <code>TinyBlob</code>, <code>MediumBlob</code>, <code>LongBlob</code>, <code>Blob</code>, <code>VarString</code>, <code>String</code>, <code>Set</code>, <code>Enum</code></td>
</tr>
<tr class="even">
<td><code>Encoding.Text</code><a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></td>
<td><code>VarChar</code>, <code>TinyBlob</code>, <code>MediumBlob</code>, <code>LongBlob</code>, <code>Blob</code>, <code>VarString</code>, <code>String</code>, <code>Set</code>, <code>Enum</code></td>
</tr>
<tr class="odd">
<td><code>Lazy.Text</code></td>
<td><code>VarChar</code>, <code>TinyBlob</code>, <code>MediumBlob</code>, <code>LongBlob</code>, <code>Blob</code>, <code>VarString</code>, <code>String</code>, <code>Set</code>, <code>Enum</code></td>
</tr>
<tr class="even">
<td><code>[Char]</code>, <code>String</code></td>
<td><code>VarChar</code>, <code>TinyBlob</code>, <code>MediumBlob</code>, <code>LongBlob</code>, <code>Blob</code>, <code>VarString</code>, <code>String</code>, <code>Set</code>, <code>Enum</code></td>
</tr>
<tr class="odd">
<td><code>UTCTime</code></td>
<td><code>DateTime</code>,<code>Timestamp</code></td>
</tr>
<tr class="even">
<td><code>Day</code></td>
<td><code>Year</code>, <code>Date</code>, <code>NewDate</code></td>
</tr>
<tr class="odd">
<td><code>TimeOfDay</code></td>
<td><code>Time</code></td>
</tr>
</tbody>
</table>
<p>As of writing, there is no support for <code>Word</code>, <code>Float</code>, or <code>Scientific</code> yet.</p>
<h1 data-number="4" id="entity-syntax" data-number="4"><span class="header-section-number">4</span> Entity Syntax</h1>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://github.com/yesodweb/persistent#learn-more-httpwwwyesodwebcombookpersistent"><code>Persistent</code> project page on GitHub</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://github.com/bitemyapp/esqueleto#setup">Esqueleto docs</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://www.yesodweb.com/book/persistent">The chapter on <code>Persistent</code> in Yesod Book</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://github.com/yesodweb/persistent/blob/master/docs/Persistent-entity-syntax.md">Persistent docs</a>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>“The default resolution for <code>TIME</code> and <code>DATETIME</code> in MySQL is one second. As of MySQL version 5.6.4, and persistent-mysql-2.6.2, fractional seconds are handled correctly if you declare an explicit precision by using <a href="https://github.com/yesodweb/persistent/blob/master/docs/Persistent-entity-syntax.md#sqltype"><code>sqltype</code></a>. For example, appending <code>sqltype=TIME(6)</code> to a <code>TimeOfDay</code> field definition will give microsecond resolution.”<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>“Support for <code>ZonedTime</code> was dropped in persistent 2.0. <code>UTCTime</code> can be used with <code>timestamp without timezone</code> and <code>timestamp with timezone</code> in PostgreSQL. See also <a href="https://github.com/yesodweb/persistent/blob/master/docs/Persistent-entity-syntax.md#times-with-timezones">the section below about timezone support</a>.”<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>“The default resolution for <code>TIME</code> and <code>DATETIME</code> in MySQL is one second. As of MySQL version 5.6.4, and persistent-mysql-2.6.2, fractional seconds are handled correctly if you declare an explicit precision by using <a href="https://github.com/yesodweb/persistent/blob/master/docs/Persistent-entity-syntax.md#sqltype"><code>sqltype</code></a>. For example, appending <code>sqltype=TIME(6)</code> to a <code>TimeOfDay</code> field definition will give microsecond resolution.”<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>“When <code>Word</code> size is 64bit.”<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>“Utf8 only.”<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></section>
</article>

<!-- <div id="disqus-thread"></div> -->
<!-- <script> -->
<!--   var disqus_config = function () { -->
<!--       this.page.identifier = '2020-03-26-haskell-persistent-sql-database'; -->
<!--   }; -->

<!--   (function () { -->
<!--       var d = document, s = d.createElement('script'); -->
<!--       s.src = 'https://demming.disqus.com/embed.js'; -->
<!--       s.setAttribute('data-timestamp', +new Date()); -->
<!--       (d.head || d.body).appendChild(s); -->
<!--   })(); -->
<!-- </script> -->
<!-- <noscript> -->
<!--     To view the --> 
<!--     <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a> -->
<!--     you need to enable JavaScript in your browser. -->
<!-- </noscript> -->
]]></summary>
</entry>
<entry>
    <title>Numerical Methods with Haskell and Python</title>
    <link href="https://demming.github.io/blog/2020/03/01/initial-value-problems/index.html" />
    <id>https://demming.github.io/blog/2020/03/01/initial-value-problems/index.html</id>
    <published>2020-03-01T00:00:00Z</published>
    <updated>2020-03-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="blog-post full">
  <header>
    <h1><a href="/blog/2020/03/01/initial-value-problems/index.html">Numerical Methods with Haskell and Python</a></h1>
    
  </header>
  <section class="post-meta internal-links">
    
    <time class="post-date">March  1, 2020</time>
    <span class="post-tags"><ul></ul></span>
  </section>
  <hr class="pre-content">
  <section class="post-content">
<div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#differential-equations"><span class="toc-section-number">1</span> Differential Equations</a></li>
<li><a href="#initial-value-problems"><span class="toc-section-number">2</span> Initial-value problems</a></li>
<li><a href="#boundary-value-problems"><span class="toc-section-number">3</span> Boundary-value problems</a></li>
<li><a href="#integral-equations"><span class="toc-section-number">4</span> Integral Equations</a></li>
<li><a href="#stochastic-differential-equations"><span class="toc-section-number">5</span> Stochastic Differential Equations</a></li>
<li><a href="#applications-of-differential-equations"><span class="toc-section-number">6</span> Applications of Differential Equations</a></li>
</ul>
</div>
<h1 data-number="1" id="differential-equations" data-number="1"><span class="header-section-number">1</span> Differential Equations</h1>
<p>A general note on differential equations. There are three classical approaches to differential equations:</p>
<ol type="1">
<li>geometric or qualitative for the study of long-term behavior of a system modeled by such an equation (mathematical physics),</li>
<li>analytic of quantitative for the solution of the equation and estimation of the solutions (functional analysis),</li>
<li>numerical for evaluation, approximation, and interpolation of solutions (numerical analysis).</li>
</ol>
<p>In practice, only a handful of differential equations admit an analytic solution, i.e., an exact closed-form solution, i.e., expressible in terms of simple functions. Thus, for actual computations with differential equations we need numerical methods. For the study of long-term behavior of the solutions, differential geometry provides us with an extraordinarily rich set of tools, which are usually used for the purpose of dimensionality reduction of the problem. All three are intertwined. <a href="...">Partial differential equations</a> (PDE) are much harder. We will constrain ourselves first to the deterministic <a href="...">ordinary differential equations</a> (ODE), as opposed to <a href="...">stochastic differential equations</a> (SDE, SPDE). More on this later.</p>
<p>We first consider only the simplest case of continuous real-valued solutions <span class="math inline">\(x : \mathbb{T} \to \mathbb{R}\)</span> defined on compact intervals <span class="math inline">\(\mathbb{T} := [a,b]\)</span> of the real line <span class="math inline">\(\mathbb{R}\)</span>.</p>
<p>An exact solution is the solution without rounding errors, otherwise it is called an approximate solution. Each initial value gives rise to another solution. The vector field <span class="math inline">\(f\)</span> defines the flow in the phase space of the problem.</p>
<h1 data-number="2" id="initial-value-problems" data-number="2"><span class="header-section-number">2</span> Initial-value problems</h1>
<p>As a side-note, an IVP is just an ODE with an initial-value condition such as <span class="math inline">\(x(a) = x_0\)</span> for a number <span class="math inline">\(x_0 \in \mathbb{R}\)</span>. The reason for considering such a constraint is that for the problem to be <a href="...">well-posed in the sense of Hadamard</a>, it must admit a unique solution that continuously depends on the data. And the “data” is everything that is “given” as the input to the problem. In its simplest general form, an IVP is stated as <span class="math display">\[\dot{x}(t) = f\big(t, x(t)\big), \quad x(a) = x_0\]</span> for <span class="math inline">\(t \in \mathbb{T}\)</span> and some <span class="math inline">\(x_0 \in X\)</span>, where <span class="math inline">\(\mathbb{T} := [a,b]\)</span> with <span class="math inline">\(a &lt; b\)</span> and <span class="math inline">\(a,b \in \mathbb{R}\)</span>, often <span class="math inline">\(a=0\)</span> and <span class="math inline">\(b=T\)</span>, for some <span class="math inline">\(T \in \mathbb{R}\)</span>, and where <span class="math inline">\(f : \mathbb{T} \times X \to \mathbb{R}\)</span> is “<em>suitably smooth</em>” and <span class="math inline">\(X \subseteq \mathbb{R}^\mathbb{T}\)</span> is a vector space of functions <span class="math inline">\(x : \mathbb{T} \to \mathbb{R}\)</span>. The notion of “suitable smoothness” refers here to the existence and uniqueness theorems guaranteeing continuous depends of the solution on the data, e.g., <a href="...">Picard–Lindelöf</a> theorems. We simply assume that <span class="math inline">\(f\)</span> is <em>uniformly Lipschitz</em>, which means that, there exists a number <span class="math inline">\(L &gt; 0\)</span> such that for all <span class="math inline">\(t \in \mathbb{T}\)</span> and for all <span class="math inline">\(x,y \in X\)</span>, <span class="math display">\[\left| f(t,x) - f(t,y) \right| \le L \lVert x - y\rVert,\]</span> where the norm on the right-hand side is understood.</p>
<p>There are also weaker and stronger conditions. We don’t need to be concerned with these details right now, though.</p>
<h1 data-number="3" id="boundary-value-problems" data-number="3"><span class="header-section-number">3</span> Boundary-value problems</h1>
<p>The distinctive characteristic of an initial-value condition is that it is taken at some point of the domain of the solution that is considered “initial”, i.e., such that all other points in the domain are ordered in sequence after it. A <a href="...">directed set</a> would suffice to capture this notion, and each interval of <span class="math inline">\(\mathbb{R}\)</span> is a directed set.</p>
<p>A boundary-value condition differs in that the values constraining the problem so as to enable the existence of a unique solution, are prescribed on the boundary of the domain of solutions, which in our simplified case are the two boundary points <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> of an interval <span class="math inline">\([a,b]\)</span>, with real <span class="math inline">\(a &lt; b\)</span>.</p>
<p>This is a more general case. Indeed, we can specify various boundary-value conditions. </p>
<p>In the case of PDEs the conditions are specified as directional derivatives with respect to a normal vector. In fact, in <span class="math inline">\(\mathbb{R}^d\)</span>, a normal space at a point <span class="math inline">\(p\)</span> is the orthogonal complement of a tangent space at <span class="math inline">\(p\)</span>, which leads to a minimization problem. More on this later.</p>
<h1 data-number="4" id="integral-equations" data-number="4"><span class="header-section-number">4</span> Integral Equations</h1>
<p>Each IVP <span class="math inline">\(\dot{x}(t) = f\big(t,x(t)\big)\)</span> with <span class="math inline">\(x(a) = x_0\)</span> can be written in form of an integral equation <span class="math display">\[x(t) = x_0 + \int_a^b f\big(t,x(t)\big) dt.\]</span></p>
<p>Both equations are equivalent, i.e., admit the same solution.</p>
<h1 data-number="5" id="stochastic-differential-equations" data-number="5"><span class="header-section-number">5</span> Stochastic Differential Equations</h1>
<p>This flavor of differential equations involves a stochastic component. Indeed, a differential equation as stated above is determined completely by the vector field <span class="math inline">\(f\)</span>. The vector field <span class="math inline">\(f\)</span> gives rise to a differential geometric quantity known as the vector flow of the equation, which describes in dependence on the initial data <span class="math inline">\(x_0\)</span> the behavior of the solution. </p>
<p>Any component of this constellation can be randomized. The equation can be given a stochastic additive term, the vector flow can be made stochastic, and so on. In other words, just make any of the components to the IVP dependent on an <span class="math inline">\(\omega \in \Omega\)</span>, where <span class="math inline">\((\Omega, \mathfrak{A}, \mathsf{P})\)</span> is a probability space, and the differential equation becomes essentially a stochastic differential equation.</p>
<p>So far this is only an heuristic manipulation of syntax. To make sense, such equations have different theories in which they can be given semantics. Two major compatible approaches are the Ito and the Stratanovich calculi, the former more widespread in mathematical finance, while the latter more widespread in (mathematical) physics.</p>
<p>We will tough this topic sometime later. This requires an introduction to stochastic calculus. A wonderful blog-style exposition is given by … Gowers TODO. Have a look if you’re curious.</p>
<p>SDEs are semantically correctly stated in the integral form but are often written heuristically in the differential form. Consider for instance the Ito diffusion process that models … TODO geometric Brownian motion used often in some popular formulations of theories in mathematical finance. </p>
<p>SDEs are used to model real-world phenomena where the influence of certain factors remains unknown, cannot be captured in detail, and is assumed to be “random”, whatever this word may mean. The idea is that the random influence is considered to be “noise” and due to lack of information on the precise evolution of such behavior, we simply average out the fluctuations, i.e., we take them into account but, depending on the admissible probability model, we average them out (by integrating against the model measure). This is a good approach in general, justified whenever we have no access to more detailed information or the details observable would make the problem too complex to solve in reasonable time (intractable). Much more on this later.</p>
<h1 data-number="6" id="applications-of-differential-equations" data-number="6"><span class="header-section-number">6</span> Applications of Differential Equations</h1>
<p>The theory of differential equations is widely applied throughout all fields of science. They are used to model real-world phenomena in terms of the rates of change of the quantities of interest in a given scientific problem. Such quantities are modeled as the so-called “features” in machine learning.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>Given a set of data points from a series of observations, a scientist tries to establish equational relations between the studied quantities that are deemed to explain their rates of change, where the quantities may depend on each other and even reflexively on themselves, maybe at different points in time.</p>
<p>In a next step, the researcher needs to verify the model. Does it conform to the data? In-sample and out-of-sample data. In machine learning, a family of models is given, and the task of choosing the model is reduced to automatically fitting the data. In conventional frequentist statistics, a model is a family of probability distributions or maybe some more general measures, depending on a parameter <span class="math inline">\(\vartheta\)</span> is given, and the task is to determine the specific distribution, i.e., the specific value, range of values of the parameter or a statistic, such that the result best fits the data. In Bayesian statistics, we are given a prior distribution and … TODO, the task is then to optimize such that … TODO. In fact, the maximum likelihood estimator amounts to an optimization problem by definition.</p>
<p>In many cases of Bayesian statistics, for instance, the computation of the integral in the denominator that is used to marginalize the joint density, is a hard problem. One therefore uses alternative methods, such as the Monte Carlo sampling methods, which amount to simulations of the distribution. And even though we can compute such integrals efficiently numerically, the problem becomes intractable as soon as we have to do this for too large a set of points! So simulation may be in fact our only hope in such a case.</p>
<p>In general, simulations are a very significant tool serving as an indicator for the consistency of the assumptions. If the simulated behavior fits well with the observed, the model may be right. We will never really know, unless the system at hand is contrived. But in the scope of our findings and our human mind, this may be just enough. Certain implicit assumptions should only be made explicit by noting that this resulting model and all predictions based upon it, depend on the observed behavior, while the phenomenon of interest may exhibit different behavior under different ambient conditions, on which it intrinsically depends. In other words, there is only so much that we can observe, assert, and analyze; and there is usually no continuity to be expected, i.e., tiny shifts may make the results contrary to the prediction. A good expert will know how to deal with such limitations of predictions. This is why we need numerical, analytical, and stochastic estimates.</p>
<p>This is studied in terms of so-called hidden or latent variables in the model. A well-known model is the hidden Markov model. TODO</p>
<p>Now, my plan is to link this all together in an exposition that is aimed to elucidate the applications of pure mathematics by means of applied mathematics to real-world problems, such as</p>
<ul>
<li>the modeling of real-estate markets,</li>
<li>the modeling of financial securities,</li>
<li>the modeling of biological systems,</li>
</ul>
<p>We will even write a few trading algorithms. Algotrading ahoy!</p>
<p>As I’m also interested in natural language processing (NLP), we will develop chatbots with language models based on differential equations.</p>
<p>But first of all, this should be fun!</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The term “feature” stems from the literature on pattern recognition in images: features of an object pictured in an image.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></section>
</article>

<!-- <div id="disqus-thread"></div> -->
<!-- <script> -->
<!--   var disqus_config = function () { -->
<!--       this.page.identifier = '2020-03-01-initial-value-problems'; -->
<!--   }; -->

<!--   (function () { -->
<!--       var d = document, s = d.createElement('script'); -->
<!--       s.src = 'https://demming.disqus.com/embed.js'; -->
<!--       s.setAttribute('data-timestamp', +new Date()); -->
<!--       (d.head || d.body).appendChild(s); -->
<!--   })(); -->
<!-- </script> -->
<!-- <noscript> -->
<!--     To view the --> 
<!--     <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a> -->
<!--     you need to enable JavaScript in your browser. -->
<!-- </noscript> -->
]]></summary>
</entry>
<entry>
    <title>Numerical Methods with Haskell and Python</title>
    <link href="https://demming.github.io/blog/2020/02/28/numerical-haskell-python/index.html" />
    <id>https://demming.github.io/blog/2020/02/28/numerical-haskell-python/index.html</id>
    <published>2020-02-28T00:00:00Z</published>
    <updated>2020-02-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article class="blog-post full">
  <header>
    <h1><a href="/blog/2020/02/28/numerical-haskell-python/index.html">Numerical Methods with Haskell and Python</a></h1>
    
  </header>
  <section class="post-meta internal-links">
    
    <time class="post-date">February 28, 2020</time>
    <span class="post-tags"><ul></ul></span>
  </section>
  <hr class="pre-content">
  <section class="post-content">
<div class="toc"><div class="header">Table of Contents</div>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#plan-for-this-series"><span class="toc-section-number">2</span> Plan for This Series</a></li>
</ul>
</div>
<h1 data-number="1" id="introduction" data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>This blog post will initiate a series of tutorial posts on formulations of numerical methods of linear algebra and analysis, and perhaps stochastics, in Haskell in comparison with Python. In the process, we will also analyze the algorithms and run benchmarks to evaluate the</p>
<ul>
<li><p>performance overhead introduced by these high-level programming languages, as compared with the standard libraries,</p></li>
<li><p>performance overhead of embedding third-party numerical libraries via the FFI, subprocess calls, and bindings — with calls directly to the original numerical libraries such as LAPACK as our benchmark.</p></li>
<li><p>ease of expression of the algorithms in terms of the number of lines of code (LOC) and the mental burden, particularly in Haskell;</p>
<p>in this regard a short note: most algorithms as formulated in books are best suited for being expressed in imperative languages such as FORTRAN, C, or Python; their translation into a purely functional language is what constituted the mental burden; once you’re used to the functional paradigm, it becomes easier; the functional paradigm fits best within a functional or modular software architecture.</p></li>
</ul>
<p>Due to the complexity of this approach, I will adopt the LEAN/Agile style of publishing here, incrementally extending the posts. If all goes well, I might <strong>publish this as a book</strong> on numerical Haskell subsequently, which I was pondering on for a while now. Of course, with the usual early-bird <strong>discounts</strong>, so stay tuned!</p>
<p>I plan to introduce an interface for comments and maybe integrate it with the most popular discussion boards such as Reddit by monitoring them for references to my domain name.</p>
<p>Moreover, a conventional blog post is usually intended to bring across the major ideas in a more or less colloquial way. In fact, it is hard to write informally about formal topics. I will try to manage a good balance between the scope of exposition and depth of formal information, without unnecessarily overburdening the reader with sometimes indeed important details, whose explanation might require an extra series of posts. So I’ll just have to gloss over them but will try to remark on their importance and point to a reference material for the interested reader. Many things therein would remain subjective. Feel free to point out any incomprehensible pieces. I will try to adopt a Medium-like marker tool to reference and comment on passages, or simply cross-post over there if it is permitted by their ToC (I haven’t consulted it just yet).</p>
<p>And as a last side-note, since I speak three languages daily, I might just mix up some idioms or other stylistic idiosyncrasies. Don’t hesitate to point it out, I’m eager to improve the clarity of expression. I know how it can “brush one against the …” (German: …), unless you’re used to it.</p>
<h1 data-number="2" id="plan-for-this-series" data-number="2"><span class="header-section-number">2</span> Plan for This Series</h1>
<p><strong>Numerical linear algebra</strong> is the working horse of virtually all numerical methods. As most problems are reduced to a linear algebra problem. Which may seem boring to an uninitiated, efficient methods of solution of the problems of linear algebra in fact are crucial to the overall efficiency of almost all numerical methods. In fact, simple post-iteration schemes can improve the quality of a solution dramatically. Similarly, the low-quality but simple explicit Euler method can be modified into the implicit Euler method that yields a dramatically better quality of the solution, by having to solve a system of linear equations in every iteration step; so if we manage to solve this linear system efficiently, we may be able to justify the use of this more complex method of significantly greater quality!</p>
<p>In fact, it may get a bit tedious and boring to be introduced to it directly, lacking relevant motivation. So we will sparingly mix it in in pieces and justify its overarching importance to our modern world.</p>
<p>We could start outright with partial differential equations, but this may seem overwhelming.</p>
<p>Our starting point is thus the <strong>numerical solution of initial-value and boundary-value problems</strong>. We will show that <strong>they reduce to standard problems of numerical linear algebra and nonlinear optimization</strong>.</p>
<p>We will conclude this series with <strong>deep learning methods applied to ODE models</strong>.</p>
<hr />
<p>As a general note valid for all my posts here, even trying hard to stay correct, but as is usual in life, mistakes are hideous, they emerge at the least expected spots. Correctness of my words is important to me. So I will greatly appreciate if you send me your corrections. Simply pointing out a potential mistake is already greatly appreciated!</p></section>
</article>

<!-- <div id="disqus-thread"></div> -->
<!-- <script> -->
<!--   var disqus_config = function () { -->
<!--       this.page.identifier = '2020-02-28-numerical-haskell-python'; -->
<!--   }; -->

<!--   (function () { -->
<!--       var d = document, s = d.createElement('script'); -->
<!--       s.src = 'https://demming.disqus.com/embed.js'; -->
<!--       s.setAttribute('data-timestamp', +new Date()); -->
<!--       (d.head || d.body).appendChild(s); -->
<!--   })(); -->
<!-- </script> -->
<!-- <noscript> -->
<!--     To view the --> 
<!--     <a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a> -->
<!--     you need to enable JavaScript in your browser. -->
<!-- </noscript> -->
]]></summary>
</entry>

</feed>
